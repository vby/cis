#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil
import re
import types
import traceback

# Constants
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'
XCMAKE_NAME = 'XCMake'
XCMAKE_VERSION='1.1.0'
XCMAKE_PROG = os.path.basename(sys.argv[0])
XCMAKE_COMMAND = os.path.abspath(sys.argv[0])
XCMAKE_DESCRIPTION = 'XCMake - CMake command-line helper'
XCMAKE_EPILOG = 'See \'%s help <command>\' to read about a specific subcommand.'%(XCMAKE_PROG)
XCMAKE_VERSION_STRING='%%(prog)s version %s\n\n%s maintained and supported by vby(Github.com/vby).\n'%(XCMAKE_VERSION, XCMAKE_NAME)
XCMAKE_CWD_ORIGIN = os.getcwd()

# Configs
DEFAULT_CMAKE_COMMAND = os.environ.get('XCMAKE_CMAKE_COMMAND') or 'cmake'
DEFAULT_CTEST_COMMAND = os.environ.get('XCMAKE_CTEST_COMMAND') or 'ctest'
DEFAULT_BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build'

INIT_CMAKELISTS = '''# Generated by %(xcmake_name)s.
cmake_minimum_required(VERSION 3.3)\n
project(%(proj)s CXX)\n
file(GLOB sources LIST_DIRECTORIES false "*.cpp")
file(GLOB_RECURSE src_sources LIST_DIRECTORIES false "src/*.cpp")
list(APPEND sources ${src_sources})\n
add_executable(%(proj)s ${sources})\n
#add_library(%(proj)s STATIC ${sources})
#add_library(%(proj)s SHARED ${sources})\n
target_include_directories(%(proj)s PUBLIC include ${include_dirs})
target_link_libraries(%(proj)s ${libs})\n
install(TARGETS %(proj)s DESTINATION bin)\n
#install(TARGETS %(proj)s DESTINATION lib)
#install(DIRECTORY src/ include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n
'''

# ArgumentParser
ARG_PARSER = None

ARG_SEPS = ('--cmake', '--build', '--make', '--')

# Parse from arguments
OPTIONS = None

# Exceptions
class XCMakeError(Exception):
	pass

def print_c(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

class ArgumentSubparsers(dict):
	def __init__(self, parent, **kw):
		dict.__init__(self)
		self.parent = parent
		self._subparsers = argparse.ArgumentParser.add_subparsers(parent, **kw)
	
	def add_parser(self, name, **kw):
		parser = self._subparsers.add_parser(name, **kw)
		parser.name = name
		parser.parent = self.parent
		self[name] = parser
		return parser

class ArgumentParser(argparse.ArgumentParser):
	def __init__(self, **kw):
		argparse.ArgumentParser.__init__(self, **kw)
		self._subparsers_list = []

	def parse_known_args(self, args=None, namespace=None, seps=None):
		if args == None:
			args = sys.argv
		if seps == None:
			seps = ARG_SEPS
		sep_args = {}
		if seps:
			xargs = []
			sep = None
			for arg in args:
				if arg in seps:
					sep = arg
					if sep not in sep_args:
						sep_args[sep] = []
					continue
				if sep:
					sep_args[sep].append(arg)
				else:
					xargs.append(arg)
			args = xargs
		options, args = argparse.ArgumentParser.parse_known_args(self, args, namespace)
		for sep in seps:
			setattr(options, 'sep' + sep.replace('-', '_'), sep_args.get(sep))
		return options, args

	def add_subparsers(self, **kw):
		subparsers = ArgumentSubparsers(self, **kw) 
		self._subparsers_list.append(subparsers)
		return subparsers

	def get_subparsers_list(self):
		return self._subparsers_list

	def get_subparsers(self):
		return self._subparsers_list[0] if self._subparsers_list else None

	def error(self, message):
		print_c('%s: %s\nSpecify --help or -h for usage'%(self.prog, message), file=sys.stderr)
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

def get_subcommand_func(name):
	return globals()['subcommand_%s'%(name.replace('-', '_'))]

def get_separated_arguments(name=''):
	return getattr(OPTIONS, 'sep__' + name, None)

def call_subcommand(name, args=None):
	if args == None:
		args = []
	sep_args = get_separated_arguments(name)
	if sep_args:
		args.extend(sep_args)
	parser = ARG_PARSER.get_subparsers()[name]
	options, unknown_args = parser.parse_known_args(args)
	options.d_func(options, unknown_args)
	
def escape_argument(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def print_arguments(args):
	print_c(' '.join((escape_argument(arg) for arg in args)), attrs='green,bold')

def call_subprocess(args, get_output=False, echo_command=True):
	if echo_command:
		print_arguments(args)
	sys.stdout.flush()
	sys.stderr.flush()
	try:
		if get_output:
			return subprocess.check_output(args, stderr=subprocess.STDOUT)
		else:
			subprocess.check_call(args)
	except OSError as e:
		raise XCMakeError('Process "%s" %s'%(args[0], str(e)))

def execute_process(command, args=None, unknown_args=None, **kw):
	argv = [command]
	if args:
		argv += args
	if unknown_args:
		for arg in unknown_args:
			if arg.startswith('++'):
				arg = '--' + arg[2:]
			elif arg.startswith('+'):
				arg = '-' + arg[1:]
			argv.append(arg) 
	return call_subprocess(argv, **kw)

def find_source_directory(from_dir = None):
	if not from_dir:
		from_dir = os.getcwd()
	while not os.path.exists(os.path.join(from_dir, CMAKELISTS)):
		from_dir, f = os.path.split(from_dir)
		if not f:
			return None
	return os.path.normpath(from_dir)

def get_source_directory():
	source_dir = getattr(get_source_directory, 'source_dir', None)
	if source_dir:
		return source_dir
	source_dir = find_source_directory()
	if not source_dir:
		raise XCMakeError('Not a cmake project (or any of the parent directories): \'%s\''%(os.getcwd()))
	get_source_directory.source_dir = source_dir
	return source_dir

def get_build_directory(source_dir = None):
	if not source_dir:
		build_dir = getattr(get_build_directory, 'build_dir', None)
		if build_dir:
			return build_dir
		fsource_dir = get_source_directory()
	else:
		fsource_dir = source_dir
	build_dir = os.path.normpath(os.path.join(fsource_dir, OPTIONS.build_dir))
	if not source_dir:
		get_build_directory.build_dir = build_dir
	return build_dir

def get_cmakecache_path(build_dir = None):
	if not build_dir:
		build_dir = get_build_directory()
	return os.path.join(build_dir, CMAKECACHE)

def is_cmakecache_exists(build_dir = None):
	cmakecache = get_cmakecache_path(build_dir) 
	return os.path.exists(cmakecache)

def remove_cmakecache(build_dir = None):
	cmakecache = get_cmakecache_path(build_dir) 
	if os.path.exists(cmakecache):
		os.remove(cmakecache)

def split_cmakecache_entry(entry):
	nametype, value = entry.split('=')
	name_type = nametype.split(':')
	vtype = name_type[1].strip() if len(name_type) > 1 else None
	return (name_type[0].strip(), vtype, value.strip())

def find_cmakecache_entry(name=None, with_type=False, allow_no_cmakecache=False):
	entries = getattr(find_cmakecache_entry, 'entries', None)
	if not entries:
		cmakecache = get_cmakecache_path() 
		if not os.path.exists(cmakecache):
			if not allow_no_cmakecache:
				raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(get_build_directory(), CMAKECACHE))
			return None
		entries = {}
		with open(cmakecache) as f:
			for line in f:
				line = line.strip()
				if not line or line.startswith('#') or line.startswith('//'):
					continue
				ename, vtype, value = split_cmakecache_entry(line)
				entries[ename] = (value, vtype)
		find_cmakecache_entry.entries = entries
	if name == None:
		return entries 
	entry = entries.get(name)
	if not with_type:
		return entry[0] if entry else ''
	return entry

def find_cmake_generator(allow_no_cmakecache=False):
	return find_cmakecache_entry('CMAKE_GENERATOR', allow_no_cmakecache=allow_no_cmakecache)

def init_cmakelists(cmakelists):
	project_name = os.path.basename(os.getcwd())
	with open(cmakelists, 'w') as f:
		f.write(INIT_CMAKELISTS % { 'xcmake_name': XCMAKE_NAME, 'proj': project_name })

def get_cmake_generators(cmake_command, no_raise=False):
	gen_lines = []
	try:
		cmake_help_text = execute_process(cmake_command, ('-h',), get_output=True, echo_command=False).decode()
		g = False 
		for line in cmake_help_text.splitlines():
			line_s = line.strip()
			if not line_s:
				continue
			if g:
				if line.endswith(':'):
					continue
				if line.startswith('    ') and gen_lines:
					gen_lines[-1] = gen_lines[-1] + ' ' + line_s
					continue
				gen_lines.append(line_s)
			elif line_s.startswith('Generators'):
				g = True
	except:
		if not no_raise:
			raise
		return None
	generators = []
	for line in gen_lines:
		lines = line.split('=')
		if len(lines) == 1:
		  continue
		gen = lines[0].strip()
		if not gen:
			continue
		gen_help = lines[1].strip()
		m = re.match(r'^(.+)\[\w+\]$', gen) 
		if m:
			gen = m.group(1).strip()
			choices = re.findall(r'"(\w+)"', gen_help)
		else:
			choices = None
		generators.append((gen, choices, gen_help))
	return generators

def fuzzy_match(words, word):
	if not word:
		return None
	if word in words:
		return word
	word_l = word.lower()
	for w in words:
		if w.lower().startswith(word_l):
			return w
	def find_chars(s, chars):
		poss = []
		pos = 0
		for c in chars:
			pos = s.find(c, pos)
			if pos < 0:
				break
			poss.append(pos)
			pos += 1
		if pos <= 0:
			return None 
		return poss 
	word_u = word.upper()
	candidates = []
	for w in words:
		poss = find_chars(w, word_u)
		if poss:
			candidates.append((w, poss))
	if not candidates:
		for w in words:
			poss = find_chars(w.lower(), word_l)
			if poss:
				candidates.append((w, poss))
	if candidates:
		if len(candidates) == 1:
			return candidates[0][0]
		c = min(candidates, key=lambda x: x[1])[0]
		m = re.match(r'^(\D+)\d+ ', c)
		if m:
			re_candidates = []
			c_s = m.group(1)
			for w, _ in candidates:
				if w.startswith(c_s):
					return w
		return c
	return None

def map_cmake_generator(cmake_command, gen):
	gen = gen.strip()
	if not gen:
		return ''
	gens = get_cmake_generators(cmake_command)
	expand_gens = []
	for g, choices, _ in gens:
		expand_gens.append(g)
		if choices:
			for choice in choices:
				expand_gens.append('%s %s'%(g, choice))
	if gen in expand_gens:
		return gen
	m = re.match(r'^\s*(\d+)\s*(\w*)$', gen)
	if m:
		idx = int(m.group(1))
		opt = m.group(2) 
		if idx > 0 and idx < len(gens):
			g, choices, _ = gens[idx-1]
			if opt:
				if choices:
					return '%s %s'%(g, fuzzy_match(choices, opt) or opt)
			else:
				return g
	return fuzzy_match(expand_gens, gen) or gen

def call_subcommand_cmake_optional():
	sep_args = get_separated_arguments('cmake')
	if sep_args != None or not is_cmakecache_exists():
		call_subcommand('cmake', sep_args)

def is_single_cfg_generator(gen=None, default=True):
	if not gen:
		gen = find_cmake_generator() 
	if not gen:
		return default
	if gen.find('Makefile') >= 0 or gen.find('Ninja') >= 0:
		return True
	return False

def extend_build_cfg_arguments(cmake_args, config):
	if config:
		cmake_args.extend(('--config', config)) 
		return
	if is_single_cfg_generator():
		return
	build_type = find_cmakecache_entry('CMAKE_BUILD_TYPE')
	if build_type:
		cmake_args.extend(('--config', build_type)) 

def extend_test_cfg_arguments(cmake_args, config):
	if config:
		cmake_args.extend(('-C', config)) 
		return
	if is_single_cfg_generator():
		return
	build_type = find_cmakecache_entry('CMAKE_BUILD_TYPE')
	if build_type:
		config = build_type 
	else:
		cfg_types = find_cmakecache_entry('CMAKE_CONFIGURATION_TYPES')
		if cfg_types:
			config = cfg_types.split(';')[0]
		else:
			config = 'Debug'
	cmake_args.extend(('-C', config))

def rebuild_msbuild_arguments(args):
	uargs = []
	uset = set()
	exclusive = False
	args.insert(0, '/verbosity:minimal')
	args.insert(0, '/nologo')
	for i in range(len(args), 0, -1):
		arg = args[i-1]
		if arg[0] == '/':
			pos = arg.find(':')
			if pos > 1:
				uarg = arg[:pos]
			else:
				uarg = arg
			if uarg in uset:
				continue
			uset.add(uarg)
			if uarg == '/version' or uarg == '/help':
				exclusive = True
		if exclusive and i <= 2:
			break
		uargs.insert(0, arg)
	return uargs

def map_make_native_argument(args, arg, param = None):
	amap = getattr(map_make_native_argument, 'amap', None)
	if amap == None:
		amap = {}
		gen = find_cmake_generator() 
		if gen and gen.find('Visual Studio') >= 0:
			amap['rebuild'] = rebuild_msbuild_arguments
			amap['property'] = lambda x: '/property:%s'%(x)
			amap['jobs'] = lambda x: '/maxcpucount' if x == None else '/maxcpucount:%d'%(x)
			amap['trace'] = '/verbosity:normal'
			amap['debug'] = lambda x: ('/verbosity:diagnostic', '/detailedsummary') if not x or x == 'a' else '/verbosity:detailed'
			amap['silent'] = '/verbosity:quiet'
			amap['help'] = '/help'
			amap['version'] = '/version'
		map_make_native_argument.amap = amap
	if not amap:
		if arg == 'rebuild':
			return args
		if arg == 'property':
			args.append(param)
		elif param:
			args.append('--%s=%s'%(arg, str(param)))
		else:
			args.append('--' + arg)
		return
	f = amap[arg]
	if arg == 'rebuild':
		return f(args) 
	if isinstance(f, types.FunctionType):
		f = f(param)
	if isinstance(f, tuple):
		args.extend(f)
	else:
		args.append(f)

def make_arguments_to_native_arguments(options):
	args = []
	# properties in targets
	targets = []
	if options.targets:
		target_set = set()
		for target in options.targets:
			if '=' in target:
				map_make_native_argument(args, 'property', target)
			else:
				if target in target_set:
					continue
				target_set.add(target)
				targets.append(target)
	# -j --jobs
	if options.jobs == None: 
		map_make_native_argument(args, 'jobs')
	elif options.jobs >= 0:
		map_make_native_argument(args, 'jobs', options.jobs)
	# --trace
	if options.trace:
		map_make_native_argument(args, 'trace')
	# -d --deubg
	if options.d or options.debug != False:
		if options.d or not options.debug:
			map_make_native_argument(args, 'debug')
		else:
			map_make_native_argument(args, 'debug', options.debug)
	# -s --silent
	if options.silent:
		map_make_native_argument(args, 'silent')
	# -h --help
	if options.help:
		map_make_native_argument(args, 'help')
	# -v --version
	if options.version:
		map_make_native_argument(args, 'version')
	return args, targets

def subcommand_init(options, unknown_args):
	cwd = os.getcwd()
	cmakelists = os.path.join(cwd, CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		init_cmakelists(cmakelists)
	except:
		if os.path.exists(cmakelists):
			os.remove(cmakelists)
		raise

def subcommand_cmake(options, unknown_args):
	source_dir = get_source_directory()
	build_dir = get_build_directory()
	cmake_args = ['-H' + source_dir, '-B' + build_dir]
	if options.G != None:
		g = map_cmake_generator(OPTIONS.cmake_command, options.G)
		if options.force:
			gen = find_cmake_generator(allow_no_cmakecache=True)
			if gen and g != gen:
				remove_cmakecache(build_dir)
		cmake_args.extend(('-G', g))
	execute_process(OPTIONS.cmake_command, cmake_args, unknown_args)

def subcommand_build(options, unknown_args):
	call_subcommand_cmake_optional()
	cmake_args = ['--build', get_build_directory()]
	if options:
		if options.target:
			cmake_args.extend(('--target', options.target))
		extend_build_cfg_arguments(cmake_args, options.config)
		if options.clean:
			cmake_args.append('--clean-first')
	if unknown_args:
		unknown_args.insert(0, '--')
	execute_process(OPTIONS.cmake_command, cmake_args, unknown_args)

def subcommand_make(options, unknown_args):
	if options.make_directory:
		os.chdir(options.make_directory)
	call_subcommand_cmake_optional()
	native_args, targets = make_arguments_to_native_arguments(options)
	if native_args:
		unknown_args.extend(native_args)
	if options.target:
		targets.append(options.target)
	unknown_args = map_make_native_argument(unknown_args, 'rebuild')
	if unknown_args:
		unknown_args.insert(0, '--')
	cmake_args = ['--build', get_build_directory()]
	if not targets:
		execute_process(OPTIONS.cmake_command, cmake_args, unknown_args)
	else:
		for target in targets:
			execute_process(OPTIONS.cmake_command, cmake_args + ['--target', target], unknown_args)

def subcommand_test(options, unknown_args):
	subcmd = 'make'
	sep_args = get_separated_arguments('make')
	if sep_args == None:
		subcmd = 'build'
		sep_args = get_separated_arguments('build')
	if sep_args != None or not is_cmakecache_exists():
		call_subcommand(subcmd, sep_args)
	cmake_args = ['-E', 'chdir', get_build_directory(), OPTIONS.ctest_command]
	extend_test_cfg_arguments(cmake_args, options.build_config)
	execute_process(OPTIONS.cmake_command, cmake_args, unknown_args)

def subcommand_clean(options, unknown_args):
	source_dir = get_source_directory()
	build_dir = get_build_directory()
	if not os.path.exists(build_dir):
		return
	if options.all:
		if source_dir == build_dir:
			raise XCMakeError('The build directory "%s" contains %s.'%(build_dir, CMAKELISTS))
		execute_process(OPTIONS.cmake_command, ['-E', 'remove_directory', build_dir])
	elif options.target:
		call_subcommand('build', ['--target', 'clean'] + unknown_args)
	else:
		remove_cmakecache(build_dir)

def subcommand_status(options, unknown_args):
	source_dir = get_source_directory()
	build_dir = get_build_directory()
	print_c('CMAKE_SOURCE_DIR = %s'%(source_dir))
	print_c('CMAKE_BINARY_DIR = ', end=None)
	has_cmakecache = False
	if not os.path.exists(build_dir):
		print_c('%s (not exists)'%(build_dir), attrs='red')
	else:
		if not is_cmakecache_exists(build_dir):
			print_c(build_dir, end=None)
			print_c(' (no %s)'%(CMAKECACHE), attrs='red')
		else:
			has_cmakecache = True
			print_c(build_dir)
	if has_cmakecache:
		names = ('CMAKE_PROJECT_NAME', 'CMAKE_GENERATOR', 'CMAKE_BUILD_TYPE', 'CMAKE_INSTALL_PREFIX')
		for name in names:
			value = find_cmakecache_entry(name)
			if name == 'CMAKE_GENERATOR':
				platform = find_cmakecache_entry(name + '_PLATFORM')
				toolset = find_cmakecache_entry(name + '_TOOLSET')
				print_c('%s = %s (PLATFORM=%s, TOOLSET=%s)'%(name, value or '', platform or '', toolset or '')) 
			else:
				print_c('%s = %s'%(name, value or '')) 

def subcommand_show(options, unknown_args):
	if options.name:
		name = options.name
		entry = find_cmakecache_entry(name, with_type=True)
		if not entry:
			raise XCMakeError('No cache entry "%s"'%(name))
		print_c('%s:%s = %s'%(name, entry[1], entry[0]))
		return
	internal_entries = []
	entries = []
	for name, (value, vtype) in find_cmakecache_entry().items(): #items() for compatible to python3
		if options.internal:
			if vtype == 'INTERNAL':
				internal_entries.append((name, value))
			continue
		if options.external:
			if vtype != 'INTERNAL':
				entries.append((name, vtype, value))
			continue
		if options.cmake:
			if name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if options.non_cmake:
			if not name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if vtype == 'INTERNAL':
			internal_entries.append((name, value))
		else:
			entries.append((name, vtype, value))
	if internal_entries:
		if not options.internal:
			print_c('INTERNAL:', attrs='cyan')
		for name, value in sorted(internal_entries):
			print_c('%s = %s'%(name, value))
	if entries:
		if not options.external and not options.cmake and not options.non_cmake:
			print_c('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			print_c('%s:%s = %s'%(name, vtype, value))

def subcommand_help(options, unknown_args):
	if options.subcommand:
		subparser = ARG_PARSER.get_subparsers().get(options.subcommand)
		if not subparser:
			raise XCMakeError('No subcommand \'%s\''%(options.subcommand))
		subparser.print_help()
	elif options.G:	
		gens = get_cmake_generators(OPTIONS.cmake_command)
		idx = 0
		for gen, choices, gen_help in gens:
			idx += 1
			print_c('%02d. %s%s'%(idx, gen, ' [%s]'%('|'.join(choices)) if choices else ''))
	else:
		ARG_PARSER.print_help()
		return

def add_subparser(subparsers, name, **kw):
	parser = subparsers.add_parser(name, **kw)
	func = get_subcommand_func(name)
	parser.set_defaults(d_subcommand=name, d_parser=parser, d_func=func)
	return parser

def add_init_parser(subparsers):
	parser = add_subparser(subparsers, 'init', help='Init a %s template'%(CMAKELISTS))

def add_cmake_parser(subparsers):
	parser = add_subparser(subparsers, 'cmake', help='Run cmake')
	parser.add_argument('-G', metavar='<generator>', help='Specify a build system generator, can be the number of %s help -G'%(XCMAKE_PROG))
	parser.add_argument('-f', '--force', action='store_true', help='Clean cache first if specify a difference generator')

def add_build_parser(subparsers, parser=None):
	if not parser:
		parser = add_subparser(subparsers, 'build', help='Run cmake --build')
	parser.add_argument('--target', metavar='<target>', help='Build <target> instead of default targets')
	parser.add_argument('--config', metavar='<config>', help='For multi-configuration tools, choose <config>')
	parser.add_argument('--clean', '--clean-first', action='store_true', help='Build target \'clean\' first, then build')

def add_make_parser(subparsers):
	parser = add_subparser(subparsers, 'make', prefix_chars='-+', help='Run cmake --build with make interface')
	parser.add_argument('targets', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', metavar='<directory>', action=PathAction, dest='make_directory', help='Change to <directory> before doing anything')
	parser.add_argument('-j', '--jobs', metavar='<n>', type=int, nargs='?', default=-1, help='Allow <n> jobs at once; infinite jobs with no arg')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='<flags>', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('-v', '--version', action='store_true', help='Print the version number of native build and exit')
	parser.add_argument('+h', '++help', action='store_true', help='Print native build help message and exit')
	group = parser.add_argument_group(title='build arguments')
	add_build_parser(subparsers, group)
	
def add_test_parser(subparsers):
	parser = add_subparser(subparsers, 'test', help='Run ctest')
	parser.add_argument('-C', '--build-config', metavar='<config>', help='Choose configuration to test')

def add_clean_parser(subparsers):
	parser = add_subparser(subparsers, 'clean', help='Clean cmake cache files')
	parser.add_argument('-a', '--all', action='store_true', help='Remove the <build-dir>')
	parser.add_argument('-t', '--target', action='store_true', help='Same as %s build --target clean'%(XCMAKE_PROG))

def add_status_parser(subparsers):
	parser = add_subparser(subparsers, 'status', help='Show the working tree status')

def add_show_parser(subparsers):
	parser = add_subparser(subparsers, 'show', help='Show cmake cache entries')
	parser.add_argument('-N', '--name', metavar='<name>', help='Show cache entry named <name>')
	parser.add_argument('--internal', action='store_true', help='Only show cache entries with type INTERNAL')
	parser.add_argument('--external', action='store_true', help='Only show cache entries with non INTERNAL type')
	parser.add_argument('--cmake', action='store_true', help='Only show cache entries with "CMAKE_" prefix')
	parser.add_argument('--non-cmake', action='store_true', help='Only show cache entries with non "CMAKE_" prefix')

def add_help_parser(subparsers):
	parser = add_subparser(subparsers, 'help', help='Show help information')
	parser.add_argument('subcommand', metavar='<subcommand>', nargs='?', help='Same as %s <subcommand> -h'%(XCMAKE_PROG))
	parser.add_argument('-G', action='store_true', help='Show cmake available generators')

def add_subparsers(parser):
	subparsers = parser.add_subparsers(title='subcommands')

	add_init_parser(subparsers)
	add_cmake_parser(subparsers)
	add_build_parser(subparsers)
	add_make_parser(subparsers)
	add_test_parser(subparsers)
	add_clean_parser(subparsers)
	add_status_parser(subparsers)
	add_show_parser(subparsers)
	add_help_parser(subparsers)

def build_argument_parser():
	parser = ArgumentParser(prog=XCMAKE_PROG, 
		description=XCMAKE_DESCRIPTION,
		epilog=XCMAKE_EPILOG,
		formatter_class=argparse.RawTextHelpFormatter,
		add_help=True)
	parser.set_defaults(d_func=None)

	parser.add_argument('-C', '--directory', metavar='<directory>', action=PathAction, help='Change to <directory> before doing anything')
	parser.add_argument('--build-dir', metavar='<build-dir>', default=DEFAULT_BUILD_DIR, help='Default \'%s\''%(DEFAULT_BUILD_DIR))
	parser.add_argument('--cmake-command', metavar='<cmake-command>', action=PathOrNameAction, default=DEFAULT_CMAKE_COMMAND, help='Default \'%s\''%(DEFAULT_CMAKE_COMMAND))
	parser.add_argument('--ctest-command', metavar='<ctest-command>', action=PathOrNameAction, default=DEFAULT_CTEST_COMMAND, help='Default \'%s\''%(DEFAULT_CTEST_COMMAND))
	parser.add_argument('-v', '--version', action='version', version=XCMAKE_VERSION_STRING, help='Print the version number of xcmake and exit')

	add_subparsers(parser)

	return parser

def main():
	global ARG_PARSER
	ARG_PARSER = build_argument_parser()

	args = sys.argv[1:]
	if not args:
		ARG_PARSER.print_help()
		return

	global OPTIONS
	options, unknown_args = ARG_PARSER.parse_known_args(args)
	OPTIONS = options

	if not options or not options.d_func:
		ARG_PARSER.print_help()
	else:
		if OPTIONS.directory:
			os.chdir(OPTIONS.directory)
		pass_args = get_separated_arguments()
		if pass_args:
			unknown_args.extend(pass_args)
		pass_args = get_separated_arguments(options.d_subcommand)
		if pass_args:
			unknown_args.extend(pass_args)
		options.d_func(options, unknown_args)

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except XCMakeError as e:
		print_c("XCMakeError: %s"%(str(e)))
	except Exception as e:
		traceback.print_exc()
		sys.exit(254)

