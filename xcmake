#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil

CMAKE_COMMAND = os.environ.get('CMAKE') or 'cmake'
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'
CMAKE_MIN_VERSION = '2.8'

XCMAKE_VERSION='1.0.0'
XCMAKE_BUILD_DIR_NAME = os.environ.get('XCMAKE_BUILD_DIR') or 'build_xcmake'
XCMAKE_BUILD_DIR = XCMAKE_BUILD_DIR_NAME
XCMAKE_INSTALL_DIR = 'out'
XCMAKE_PROG = 'xcmake'
XCMAKE_DESCRIPTION = 'XCMake - Make frontend for cmake'

XCMAKE_ARGS = None

class XCMakeError(Exception):
	pass

def print_color(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

def subp_escape(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def subp_check_call(args, output=False, echo=True):
	if echo:
		print_color(' '.join((subp_escape(arg) for arg in args)), attrs='green,bold')
	sys.stdout.flush()
	sys.stderr.flush()
	if output:
		return subprocess.check_output(args)
	else:
		subprocess.check_call(args)

def do_scratch(cmakelists):
	project_name = os.path.basename(XCMAKE_ARGS.directory)
	with open(cmakelists, 'w') as f:
		f.write('# Generated by XCMAKE.\n')
		f.write('cmake_minimum_required(VERSION %s)\n\n'%(CMAKE_MIN_VERSION))
		f.write('project(%s)\n\n'%(project_name))
		f.write('#include_directories(${include_dirs})\n\n')
		f.write('#link_directories(${link_dirs})\n\n')
		f.write('file(GLOB sources "src/*.cpp")\n\n')
		f.write('add_executable(%s ${sources})\n\n'%(project_name))
		f.write('#target_link_libraries(%s ${libs})\n\n'%(project_name))
		f.write('#add_library(%s_shared SHARED ${sources})\n\n'%(project_name))
		f.write('#add_library(%s_static STATIC ${sources})\n\n'%(project_name))
		f.write('set(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_SOURCE_DIR}/%s/%s")\n\n'%(XCMAKE_BUILD_DIR_NAME, XCMAKE_INSTALL_DIR))
		f.write('install(TARGETS %s DESTINATION "bin")\n\n'%(project_name))
		f.write('install(DIRECTORY "include/" DESTINATION "include" FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n\n')
		f.write('#install(TARGETS %s_shared DESTINATION "lib")\n\n'%(project_name))
		f.write('#install(TARGETS %s_static DESTINATION "lib")\n\n'%(project_name))

def do_cmake(args=None, output=False, echo=True, native_args=None, with_hyphen_argv=True):
	cmake_argv = [CMAKE_COMMAND]
	if args:
		cmake_argv += args
	if with_hyphen_argv and XCMAKE_ARGS.hyphen_argv:
		cmake_argv += XCMAKE_ARGS.hyphen_argv
	if native_args:
		if '--' not in cmake_argv:
			cmake_argv.append('--')
		cmake_argv += native_args
	return subp_check_call(cmake_argv, output, echo)

def find_cache_entry(name=None):
	if hasattr(find_cache_entry, 'entries'):
		entries = find_cache_entry.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		return entry[0] if entry else ''
	cmakecache = os.path.join(XCMAKE_BUILD_DIR, CMAKECACHE)
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(XCMAKE_BUILD_DIR, CMAKECACHE))
	entries = {}
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			entry, value = line.split('=')
			ename, vtype = entry.split(':')
			entries[ename] = (value, vtype)
	find_cache_entry.entries = entries
	return find_cache_entry(name)


def cmake_generators():
	generators = []
	try:
		cmake_help_text = do_cmake(('-h',), with_hyphen_argv=False, output=True, echo=False).decode('utf8')
		g = False 
		for line in cmake_help_text.splitlines():
			if g:
				generators.append(line)
			elif line.lstrip().startswith('Generators'):
				g = True
	except Exception as e:
		pass
	return generators

def command_version():
	sys.stdout.write('%s version %s\n\n'%(XCMAKE_PROG, XCMAKE_VERSION))
	do_cmake(('--version',), echo=False)

def command_scratch():
	cmakelists = os.path.abspath(CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		do_scratch(cmakelists)
	except:
		os.remove(cmakelists)
		raise

def command_cmake():
	do_cmake(['-E', 'chdir', XCMAKE_BUILD_DIR, CMAKE_COMMAND])

def do_update(with_hyphen_argv=True):
	argv = ['-H' + XCMAKE_ARGS.directory, '-B' + XCMAKE_BUILD_DIR]
	if XCMAKE_ARGS.U:
		for u in XCMAKE_ARGS.U:
			argv.append('-D' + u)
	if XCMAKE_ARGS.D:
		for d in XCMAKE_ARGS.D:
			argv.append('-D' + d)
	if XCMAKE_ARGS.generator != None:
		argv += ['-G', XCMAKE_ARGS.generator]
	if XCMAKE_ARGS.toolset != None:
		argv += ['-T', XCMAKE_ARGS.toolset]
	if XCMAKE_ARGS.platform != None:
		argv += ['-A', XCMAKE_ARGS.platform]
	if XCMAKE_ARGS.trace_expand:
		argv.append('--trace-expand')
	elif XCMAKE_ARGS.trace:
		argv.append('--trace')
	if XCMAKE_ARGS.debug != False:
		argv.append('--debug-output')
	do_cmake(argv, with_hyphen_argv=with_hyphen_argv)

def command_update():
	do_update(with_hyphen_argv=True)

def do_build_target(target=None, args=None, native_args=None):
	argv = ['--build', XCMAKE_BUILD_DIR]
	if args:
		argv += args
	if target:
		argv += ['--target', target]
	do_cmake(argv, native_args=native_args)

def build_native_arg(arg):
	if hasattr(build_native_arg, 'args'):
		return build_native_arg.args.get(arg)
	args = {}
	gen = find_cache_entry('CMAKE_GENERATOR')
	if gen and gen.find('Visual Studio') >= 0:
		args['property'] = '/p:%s'
		args['jobs'] = ('/m', '/m:%d')
		args['trace'] = '/v:d' 
		args['debug'] = ('/v:diag', lambda x: '/v:diag' if x == 'a' else '/v:d')
		args['silent'] = ('/nologo', '/v:q')
	else:
		args['property'] = '%s'
		args['jobs'] = ('-j', '-j%d')
		args['trace'] = '--trace' 
		args['debug'] = ('-d', lambda x: '--debug=%s'%(x))
		args['silent'] = ('-s',)
	build_native_arg.args = args
	return build_native_arg(arg)

def build_native_args():
	args = []
	# properties in targets
	if XCMAKE_ARGS.target:
		targets = []
		for target in XCMAKE_ARGS.target:
			if '=' in target:
				args.append(build_native_arg('property')%(target))
			else:
				targets.append(target)
		XCMAKE_ARGS.target = targets
	# -j --jobs
	if XCMAKE_ARGS.jobs == None: 
		args.append(build_native_arg('jobs')[0])
	elif XCMAKE_ARGS.jobs >= 0:
		args.append(build_native_arg('jobs')[1]%(XCMAKE_ARGS.jobs))
	# --trace
	if XCMAKE_ARGS.trace:
		args.append(build_native_arg('trace'))
	# -d --deubg
	if XCMAKE_ARGS.debug != False:
		if XCMAKE_ARGS.debug == '':
			args.append(build_native_arg('debug')[0])
		else:
			args.append(build_native_arg('debug')[1](XCMAKE_ARGS.debug))
	# -s --silent
	if XCMAKE_ARGS.silent:
		args.extend(build_native_arg('silent'))
	return args

def command_build(update=True):
	if update and not os.path.exists(os.path.join(XCMAKE_BUILD_DIR, CMAKECACHE)):
		do_update(with_hyphen_argv=False)
	args = None
	if XCMAKE_ARGS.config:
		args = ['--config', XCMAKE_ARGS.config] 
	else:
		build_type = find_cache_entry('CMAKE_BUILD_TYPE')
		if build_type:
			args = ['--config', build_type] 
	native_args = build_native_args()
	if not XCMAKE_ARGS.target:
		return do_build_target(None, args, native_args)
	targets = set()
	for target in XCMAKE_ARGS.target:
		if target in targets:
			continue
		targets.add(target)
		do_build_target(target, args, native_args)

def command_update_build():
	do_update(with_hyphen_argv=False)
	command_build(update=False)

def command_clean():
	if os.path.exists(XCMAKE_BUILD_DIR):
		if XCMAKE_ARGS.directory == XCMAKE_BUILD_DIR:
			raise XCMakeError('The build directory "%s" is source directory.'%(XCMAKE_BUILD_DIR))
	do_cmake(('-E', 'remove_directory', XCMAKE_BUILD_DIR))

def command_show(status=False):
	internal_entries = []
	cmake_entries = []
	entries = []
	for name, (value, vtype) in find_cache_entry().items():
		if not value:
			continue
		if vtype == 'INTERNAL':
			if not status or (name.startswith('CMAKE_GENERATOR') or name.endswith('_COMMAND') or name.endswith('_DIR') or name.endswith('_DIRECTORY')):
				internal_entries.append((name, value))
			continue
		if vtype == 'PATH' or vtype == 'FILEPATH':
			if value.endswith('-NOTFOUND'):
				continue
		if name.startswith('CMAKE_'):
			if status:
				if name.endswith('_PREFIX'):
					cmake_entries.append((name, vtype, value))
			else:
				cmake_entries.append((name, vtype, value))
		else:
			if not status:
				entries.append((name, vtype, value))
	print_color('INTERNAL:', attrs='cyan')
	for name, value in sorted(internal_entries):
		sys.stdout.write('%s=%s\n'%(name, value))
	if cmake_entries:
		print_color('EXTERNAL-CMAKE:', attrs='cyan')
		for name, vtype, value in sorted(cmake_entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))
	if entries:
		print_color('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

def command_status():
	command_show(status=True)

def print_help(parser, fd=sys.stdout):
	parser.print_help()
	fd.write('\nGenerators\n%s\n'%('\n'.join(cmake_generators())))

def command_help(parser):
	print_help(parser)
	sys.exit(0)

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\n\n'%(self.prog, message))
		print_help(self, sys.stderr)
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(values))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(values))

def adjust_arguments(parser, hyphen_argv):
	# show help
	if XCMAKE_ARGS.help:
		command_help(parser)
	# chdir to --directory
	if XCMAKE_ARGS.directory:
		os.chdir(XCMAKE_ARGS.directory)
	else:
		XCMAKE_ARGS.directory = os.getcwd()
	# --debug
	if XCMAKE_ARGS.debug:
		if 'n' in XCMAKE_ARGS.debug:
			XCMAKE_ARGS.debug = False
			XCMAKE_ARGS.d = False
	if XCMAKE_ARGS.debug == None or (XCMAKE_ARGS.d and not XCMAKE_ARGS.debug):
		XCMAKE_ARGS.debug = 'a'
	# set --trace for --trace-expand
	if XCMAKE_ARGS.trace_expand:
		XCMAKE_ARGS.trace = True
	# --silent
	if XCMAKE_ARGS.silent:
		XCMAKE_ARGS.debug = False
		XCMAKE_ARGS.trace = False
		XCMAKE_ARGS.trace_expand = False
	# set --cmake-command
	global CMAKE_COMMAND
	CMAKE_COMMAND = XCMAKE_ARGS.cmake_command
	# set --build-dir
	global XCMAKE_BUILD_DIR
	if not os.path.dirname(XCMAKE_ARGS.build_dir):
		XCMAKE_BUILD_DIR = os.path.abspath(XCMAKE_ARGS.build_dir)
	else:
		XCMAKE_BUILD_DIR = XCMAKE_ARGS.build_dir
	# set --update for -G -T -A -D -U
	if not XCMAKE_ARGS.update:
		if XCMAKE_ARGS.generator != None or XCMAKE_ARGS.toolset != None or XCMAKE_ARGS.platform != None or XCMAKE_ARGS.D or XCMAKE_ARGS.U:
			XCMAKE_ARGS.update = True
	# set -- //
	setattr(XCMAKE_ARGS, 'hyphen_argv', hyphen_argv)

def split_arguments(argv):
	args = [arg if arg != '//' else '--' for arg in argv]
	hyphen_arg_idx = 0
	for arg in args:
		hyphen_arg_idx += 1
		if arg == '--cmake' or arg == '--':
			break
	return (args[:hyphen_arg_idx], args[hyphen_arg_idx:]) 

def parse_arguments(argv):
	parser = ArgumentParser(prog=XCMAKE_PROG, 
		prefix_chars='-/',
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description=XCMAKE_DESCRIPTION, 
		add_help=False)
	# make
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-h', '--help', '/?', action='store_true', help='Print this message and exit')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('-v', '--version', '/V', action='store_true', help='Print the version number of xcmake and exit')
	# cmake extend
	parser.add_argument('--trace-expand', action='store_true', help='Trace with variable expansion')
	# common
	parser.add_argument('-c', '--cmake-command', action=PathOrNameAction, default=CMAKE_COMMAND, help='Default "%s"'%(CMAKE_COMMAND))
	parser.add_argument('-b', '--build-dir', action=PathOrNameAction, default=XCMAKE_BUILD_DIR, help='Default "%s"'%(XCMAKE_BUILD_DIR))
	# command scratch
	parser.add_argument('--scratch', action='store_true', help='Create a %s template'%(CMAKELISTS))
	# command update
	parser.add_argument('--update', action='store_true', help='Create or update CMake cache')
	parser.add_argument('-G', '--generator', help='Specify a build system generator')
	parser.add_argument('-T', '--toolset', help='Specify toolset name if supported by GENERATOR')
	parser.add_argument('-A', '--platform', help='Specify platform name if supported by GENERATOR')
	# BUG of parser: '[' in metavar
	parser.add_argument('-D', metavar='<var>{:<type>}=<value>', action='append', help='Create a cmake cache entry')
	parser.add_argument('-U', metavar='<globbing_expr>', action='append', help='Remove matching entries from CMake cache')
	# command build
	parser.add_argument('--build', action='store_true', help='Make targets')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')
	# command clean
	parser.add_argument('--clean', action='store_true', help='Remove BUILD_DIR')
	# command status
	parser.add_argument('--status', action='store_true', help='Show cache status')
	# command show
	parser.add_argument('--show', action='store_true', help='Show cache entries')
	# command cmake
	parser.add_argument('--cmake', action='store_true', help='Run cmake in BUILD_DIR')
	# only for help
	parser.add_argument('--', dest='hyphen_argv', metavar='or //', help='Pass remaining options to cmake')

	global XCMAKE_ARGS

	args, hyphen_argv = split_arguments(argv)

	XCMAKE_ARGS = parser.parse_args(args)

	adjust_arguments(parser, hyphen_argv)

def main():
	parse_arguments(sys.argv[1:])
	
	#print(XCMAKE_ARGS)
	if XCMAKE_ARGS.version:
		return command_version()
	if XCMAKE_ARGS.cmake:
		return command_cmake()
	if XCMAKE_ARGS.status:
		return command_status()
	if XCMAKE_ARGS.show:
		return command_show()
	if XCMAKE_ARGS.scratch:
		return command_scratch()
	if XCMAKE_ARGS.clean:
		return command_clean()
	if XCMAKE_ARGS.update and XCMAKE_ARGS.build:
		return command_update_build()
	if XCMAKE_ARGS.update:
		return command_update()
	return command_build()

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

