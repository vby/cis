#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil
import re
import types

CMAKE_COMMAND = os.environ.get('XCMAKE_CMAKE_COMMAND') or 'cmake'
CTEST_COMMAND = os.environ.get('XCMAKE_CTEST_COMMAND') or 'ctest'
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'

class XCMAKE:
	NAME = 'XCMake'
	VERSION='1.1.0'
	DESCRIPTION = 'XCMake - CMake command-line helper'
	PROG = os.path.basename(sys.argv[0])
	COMMAND = os.path.abspath(sys.argv[0])
	BUILD_DIR_NAME = os.environ.get('XCMAKE_BUILD_DIR_NAME') or 'build'
	SEARCH_CMAKELISTS = True
	CMAKE_MIN_VERSION = '3.3'

VisualStudioVersionMap = {
	7: '7 .NET 2003',
	8: '8 2005',
	9: '9 2008',
	2002: '.NET 2002', # Removed since CMake 3.6
	2003: '7 .NET 2003',
	2005: '8 2005',
	2008: '9 2008',
	2010: '10',
	2012: '11',
	2013: '12',
	2015: '14',
	2017: '15',
}

VisualStudioArchMap = {
	'x86': '',
	'x64': 'Win64',
	'x86_64': 'Win64',
	'arm': 'ARM',
	'ia64': 'IA64',
}

class XCMakeError(Exception):
	pass

def print_color(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

def argument_text_escape(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def print_command(args):
	print_color(' '.join((argument_text_escape(arg) for arg in args)), attrs='green,bold')

def call_subprocess(args, get_output=False, echo_command=True):
	if echo_command:
		print_command(args)
	sys.stdout.flush()
	sys.stderr.flush()
	if get_output:
		return subprocess.check_output(args, stderr=subprocess.STDOUT)
	else:
		subprocess.check_call(args)

def print_version():
	sys.stdout.write('%s version %s\n\n%s maintained and supported by vby (Github.com/vby).\n'
			%(XCMAKE.PROG, XCMAKE.VERSION, XCMAKE.NAME)
		)

def find_cmakelists_directory(cdir = os.getcwd()):
	while not os.path.exists(os.path.join(cdir, CMAKELISTS)):
		cdir, f = os.path.split(cdir)
		if not f:
			return None
	return os.path.normpath(cdir)

def get_cmakelists_directory(cdir = None):
	if not cdir:
		cdir = getattr(get_cmakelists_directory, 'cmakelists_dir', None)
		if cdir:
			return cdir
		cdir = os.getcwd()
	fcdir = find_cmakelists_directory(cdir)
	if not fcdir:
		raise XCMakeError('Not a cmake project (or any of the parent directories): %s'%(CMAKELISTS))
	if not cdir:
		setattr(get_cmakelists_directory, 'cmakelists_dir', fcdir)
	return fcdir

def change_to_cmakelists_directory():
	cdir = get_cmakelists_directory()
	if cdir != cwd:
		os.chdir(cdir)
		cwd = cdir
	return cwd

def get_build_directory(cmakelists_dir = None):
	if not cmakelists_dir:
		cmakelists_dir = get_cmakelists_directory()
	return os.path.normpath(os.path.join(cmakelists_dir, XCMAKE.BUILD_DIR_NAME))

def get_cmakecache_file(build_dir = None):
	if not build_dir:
		build_dir = get_build_directory()
	return os.path.join(build_dir, CMAKECACHE)

def remove_cmakecache(build_dir = None):
	cmakecache = get_cmakecache_file(build_dir) 
	if os.path.exists(cmakecache):
		os.remove(cmakecache)

def split_cmakecache_entry(entry):
	nametype, value = entry.split('=')
	name_type = nametype.split(':')
	vtype = name_type[1].strip() if len(name_type) > 1 else None
	return (name_type[0].strip(), vtype, value.strip())

def find_cmakecache_entry(name=None, with_type=False, allow_no_cmakecache=False):
	entries = getattr(find_cmakecache_entry, 'entries', None)
	if not entries:
		cmakecache = get_cmakecache_file() 
		if not os.path.exists(cmakecache):
			if not allow_no_cmakecache:
				raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(get_build_directory(), CMAKECACHE))
			return None
		entries = {}
		with open(cmakecache) as f:
			for line in f:
				line = line.strip()
				if not line or line.startswith('#') or line.startswith('//'):
					continue
				ename, vtype, value = split_cmakecache_entry(line)
				entries[ename] = (value, vtype)
		find_cmakecache_entry.entries = entries
	if name == None:
		return entries 
	entry = entries.get(name)
	if not with_type:
		return entry[0] if entry else ''
	return entry

def find_cmakecache_generator(allow_no_cmakecache=False):
	return find_cmakecache_entry('CMAKE_GENERATOR', allow_no_cmakecache=allow_no_cmakecache)

def scratch(cwd, cmakelists):
	project_name = os.path.basename(cwd)
	with open(cmakelists, 'w') as f:
		f.write(
'''# Generated by %(xcmake_name)s.
cmake_minimum_required(VERSION %(min_ver)s)\n
project(%(proj)s CXX)\n
file(GLOB sources LIST_DIRECTORIES false "*.cpp")
file(GLOB_RECURSE src_sources LIST_DIRECTORIES false "src/*.cpp")
list(APPEND sources ${src_sources})\n
add_executable(%(proj)s ${sources})\n
#add_library(%(proj)s STATIC ${sources})
#add_library(%(proj)s SHARED ${sources})\n
target_include_directories(%(proj)s PUBLIC include ${include_dirs})
target_link_libraries(%(proj)s ${libs})\n
install(TARGETS %(proj)s DESTINATION bin)\n
#install(TARGETS %(proj)s DESTINATION lib)
#install(DIRECTORY src/ include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n
'''		%{
			'xcmake_name': XCMAKE.NAME,
			'min_ver': XCMAKE.CMAKE_MIN_VERSION,
			'proj': project_name,
		})

def execute_process(command, args=None, pass_args=None, get_output=False, echo_command=True):
	argv = [command]
	if args:
		argv += args
	if pass_args:
		for arg in pass_args:
			if arg.startswith('++'):
				arg = '--' + arg[2:]
			elif arg[0] == '+':
				arg = '-' + arg[1:]
			argv.append(arg) 
	return call_subprocess(argv, get_output, echo_command)

def get_cmake_generators(cmake_command, no_raise = False):
	generators = []
	try:
		cmake_help_text = execute_process(cmake_command, ('-h',), get_output=True, echo_command=False).decode()
		g = False 
		for line in cmake_help_text.splitlines():
			line = line.strip()
			if not line:
				continue
			if g:
				if line.endswith(':') or line.startswith('='):
					continue
				lines = line.split('=')
				if len(lines) == 1 and line.endswith('.'):
					continue
				generators.append(lines[0].strip())
			elif line.startswith('Generators'):
				g = True
	except:
		if not no_raise:
			raise
	return generators

def map_cmake_generator(cmake_command, g):
	m = re.match('^\s*[vV][sS]\s*(\d+)(.*)', g)
	if m:
		ver = m.group(1)
		ver = VisualStudioVersionMap.get(int(ver), ver)
		arch = m.group(2).strip()
		arch = VisualStudioArchMap.get(arch.lower(), arch)
		return 'Visual Studio %s%s'%(ver, ' ' + arch if arch else '')
	m = re.match('^\s*(\d+)\s*$', g)
	if m:
		idx = int(m.group(1))
		if idx > 0:
			gens = get_cmake_generators(cmake_command, no_raise=True)
			if gens and idx < len(gens):
				return gens[idx-1]
	return g.strip()

def extend_build_config(options, cmake_args):
	if not options:
		return
	if options.config:
		cmake_args.extend(('--config', options.config)) 
	else:
		build_type = find_cmakecache_entry('CMAKE_BUILD_TYPE')
		if build_type:
			cmake_args.extend(('--config', build_type)) 

def unique_msbuild_arguments(args):
	uargs = []
	uset = set()
	for arg in reversed(args):
		if arg[0] == '/':
			pos = arg.find(':')
			if pos > 1:
				uarg = arg[:pos]
			else:
				uarg = arg
			if uarg in uset:
				continue
			uset.add(uarg)
		uargs.insert(0, arg)
	return uargs

def map_make_native_argument(args, arg, param = None):
	amap = getattr(map_make_native_argument, 'amap', None)
	if amap == None:
		amap = {}
		gen = find_cmakecache_generator() 
		#if gen and gen.find('Visual Studio') >= 0:
		if gen:
			amap['defaults'] = ('/nologo', '/verbosity:minimal')
			amap['unique'] = unique_msbuild_arguments 
			amap['property'] = lambda x: '/property:%s'%(x)
			amap['jobs'] = lambda x: '/maxcpucount' if x == None else '/maxcpucount:%d'%(x)
			amap['trace'] = '/verbosity:normal'
			amap['debug'] = lambda x: ('/verbosity:diagnostic', '/detailedsummary') if not x or x == 'a' else '/verbosity:detailed'
			amap['silent'] = '/verbosity:quiet'
			amap['help'] = '/help'
			amap['version'] = '/version'
		map_make_native_argument.amap = amap
	if not amap:
		if arg == 'unique':
			return arg
		if arg != 'defaults':
			args.append('--' + arg)
		return
	f = amap[arg]
	if arg == 'unique':
		return f(args) 
	if isinstance(f, types.FunctionType):
		f = f(param)
	if isinstance(f, tuple):
		args.extend(f)
	else:
		args.append(f)

def make_arguments_to_native_arguments(options):
	args = []
	map_make_native_argument(args, 'defaults')
	# properties in targets
	targets = []
	if options.targets:
		target_set = set()
		for target in options.targets:
			if '=' in target:
				map_make_native_argument(args, 'property', target)
			else:
				if target in target_set:
					continue
				target_set.add(target)
				targets.append(target)
	# -j --jobs
	if options.jobs == None: 
		map_make_native_argument(args, 'jobs')
	elif options.jobs >= 0:
		map_make_native_argument(args, 'jobs', options.jobs)
	# --trace
	if options.trace:
		map_make_native_argument(args, 'trace')
	# -d --deubg
	if options.d or options.debug != False:
		if options.d or not options.debug:
			map_make_native_argument(args, 'debug')
		else:
			map_make_native_argument(args, 'debug', options.debug)
	# -s --silent
	if options.silent:
		map_make_native_argument(args, 'silent')
	# -h --help
	if options.help:
		map_make_native_argument(args, 'help')
	# -v --version
	if options.version:
		map_make_native_argument(args, 'version')
	return args, targets

def subcommand_init(options, pass_args):
	cwd = os.getcwd()
	cmakelists = os.path.join(cwd, CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		scratch(cwd, cmakelists)
	except:
		if os.path.exists(cmakelists):
			os.remove(cmakelists)
		raise

def subcommand_cmake(options, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	cmake_args = ['-H' + cmakelists_dir, '-B' + build_dir]
	if options:
		if options.G:
			g = map_cmake_generator(XCMAKE.cmake_command, options.G)
			if options.force:
				gen = find_cmakecache_generator(allow_no_cmakecache=True)
				if gen and g != gen:
					remove_cmakecache(build_dir)
			cmake_args.extend(('-G', g))
	execute_process(XCMAKE.cmake_command, cmake_args, pass_args)

def subcommand_build(options, pass_args):
	build_dir = get_build_directory()
	cmakecache = get_cmakecache_file(build_dir)
	if not os.path.exists(cmakecache):
		subcommand_cmake(None, None)
	cmake_args = ['--build', build_dir]
	extend_build_config(options, cmake_args)
	execute_process(XCMAKE.cmake_command, cmake_args, pass_args)

def subcommand_make(options, pass_args):
	if options.directory:
		os.chdir(options.directory)
	if pass_args == None:
		pass_args = []
	native_args, targets = make_arguments_to_native_arguments(options)
	if native_args:
		pass_args.extend(native_args)
	pass_args = map_make_native_argument(pass_args, 'unique')
	if not targets:
		subcommand_build(options, ['--'] + pass_args)
	else:
		for target in targets:
			subcommand_build(options, ['--target', target, '--'] + pass_args)

def subcommand_ctest(options, pass_args):
	cmakecache = get_cmakecache_file()
	if not os.path.exists(cmakecache):
		subcommand_cmake(None, None)
	cmake_args = ['-E', 'chdir', get_build_directory(), XCMAKE.ctest_command]
	execute_process(XCMAKE.cmake_command, cmake_args, pass_args)

def subcommand_clean(options, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	if not os.path.exists(build_dir):
		return
	if options.all:
		if cmakelists_dir == build_dir:
			raise XCMakeError('The build directory "%s" contains %s.'%(build_dir, CMAKELISTS))
		execute_process(XCMAKE.cmake_command, ['-E', 'remove_directory', build_dir])
	elif options.target:
		pass_args.extend(('--target', 'clean'))
		subcommand_build(None, pass_args) 
	else:
		remove_cmakecache(build_dir)

def subcommand_status(options, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	sys.stdout.write('Source directory: %s\n'%(cmakelists_dir))
	sys.stdout.write('Binary directory: %s\n'%(build_dir))

def subcommand_show(options, pass_args):
	if options.name:
		name = options.name
		entry = find_cmakecache_entry(name, True)
		if not entry:
			raise XCMakeError('No cache entry "%s"'%(name))
		sys.stdout.write('%s:%s=%s\n'%(name, entry[1], entry[0]))
		return
	internal_entries = []
	entries = []
	for name, (value, vtype) in find_cmakecache_entry().items(): #items() for compatible to python3
		if options.internal:
			if vtype == 'INTERNAL':
				internal_entries.append((name, value))
			continue
		if options.external:
			if vtype != 'INTERNAL':
				entries.append((name, vtype, value))
			continue
		if options.cmake:
			if name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if options.non_cmake:
			if not name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if vtype == 'INTERNAL':
			internal_entries.append((name, value))
		else:
			entries.append((name, vtype, value))
	if internal_entries:
		if not options.internal:
			print_color('INTERNAL:', attrs='cyan')
		for name, value in sorted(internal_entries):
			sys.stdout.write('%s=%s\n'%(name, value))
	if entries:
		if not options.external and not options.cmake and not options.non_cmake:
			print_color('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

def subcommand_help(options, pass_args):
	if not options:
		XCMAKE.subparser_help.print_help()
		return
	if options.subcommand:
		subparser = XCMAKE.subparsers.get(options.subcommand)
		if not subparser:
			raise XCMakeError('No subcommand "%s"'%(options.subcommand))
		subparser.print_help()
	elif options.G:	
		gens = get_cmake_generators(XCMAKE.cmake_command)
		idx = 0
		for gen in gens:
			idx += 1
			sys.stdout.write('%02d. %s\n'%(idx, gen))

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\nSpecify --help or -h for usage\n'%(self.prog, message))
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

def add_parser(subparsers, name, *args, **kw):
	parser = subparsers.add_parser(name, *args, **kw)
	func = globals()['subcommand_%s'%(name.replace('-', '_'))]
	parser.set_defaults(parser=parser, func=func)
	subparser_dict = getattr(subparsers, 'subparser_dict', None)
	if not subparser_dict:
		subparser_dict = {name: parser}
		setattr(subparsers, 'subparser_dict', subparser_dict)
	else:
		subparser_dict[name] = parser
	return parser

def add_init_parser(subparsers):
	parser = add_parser(subparsers, 'init', help='Create a %s template'%(CMAKELISTS))

def add_cmake_parser(subparsers):
	parser = add_parser(subparsers, 'cmake', help='Run cmake')
	parser.add_argument('-G', metavar='GENERATOR', help='Specify a build system generator, can be the number of %s help -G'%(XCMAKE.PROG))
	parser.add_argument('-f', '--force', action='store_true', help='Clean cache first if specify a difference generator')

def add_build_parser(subparsers, parser=None):
	if not parser:
		parser = add_parser(subparsers, 'build', help='Run cmake --build')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')

def add_make_parser(subparsers):
	parser = add_parser(subparsers, 'make', prefix_chars='-+', help='Run cmake --build by make interface')
	parser.add_argument('targets', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('+h', '++help', action='store_true', help='Print native build help message and exit')
	parser.add_argument('+v', '++version', action='store_true', help='Print the version number of native build and exit')
	add_build_parser(subparsers, parser)
	
def add_ctest_parser(subparsers):
	parser = add_parser(subparsers, 'ctest', help='Run ctest')

def add_clean_parser(subparsers):
	parser = add_parser(subparsers, 'clean', help='Clean cmake cache')
	parser.add_argument('-a', '--all', action='store_true', help='Remove the BUILD_DIR')
	parser.add_argument('--target', action='store_true', help='Same as %s cmake build --target clean'%(XCMAKE.PROG))

def add_status_parser(subparsers):
	parser = add_parser(subparsers, 'status', help='Show the working tree status')

def add_show_parser(subparsers):
	parser = add_parser(subparsers, 'show', help='Show cmake cache entries')
	parser.add_argument('-N', '--name', help='Show cache entry named NAME')
	parser.add_argument('--internal', action='store_true', help='Only show cache entries with type INTERNAL')
	parser.add_argument('--external', action='store_true', help='Only show cache entries with non INTERNAL type')
	parser.add_argument('--cmake', action='store_true', help='Only show cache entries with "CMAKE_" prefix')
	parser.add_argument('--non-cmake', action='store_true', help='Only show cache entries with non "CMAKE_" prefix')

def add_help_parser(subparsers):
	parser = add_parser(subparsers, 'help', help='Show help information')
	parser.add_argument('subcommand', nargs='?', help='Same as %s SUBCOMMAND -h'%(XCMAKE.PROG))
	parser.add_argument('-G', action='store_true', help='Show cmake available generators')

def add_subparsers(parser):
	if parser: 
		subparser = ArgumentParser(parents=(parser,))
	else:
		subparser = ArgumentParser()
	subparsers = subparser.add_subparsers(title='subcommands')

	add_init_parser(subparsers)
	add_cmake_parser(subparsers)
	add_build_parser(subparsers)
	add_make_parser(subparsers)
	add_ctest_parser(subparsers)
	add_clean_parser(subparsers)
	add_status_parser(subparsers)
	add_show_parser(subparsers)
	add_help_parser(subparsers)

	return subparser, subparsers.subparser_dict

def create_parser(add_help):
	parser = ArgumentParser(prog=XCMAKE.PROG, 
		description=XCMAKE.DESCRIPTION,
		add_help=False)
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('--cmake-command', action=PathOrNameAction, default=CMAKE_COMMAND, help='Default "%s"'%(CMAKE_COMMAND))
	parser.add_argument('--ctest-command', action=PathOrNameAction, default=CTEST_COMMAND, help='Default "%s"'%(CTEST_COMMAND))
	if add_help:
		parser.add_argument('-h', '--help', action='store_true', help='Print this message and exit')
	parser.add_argument('-v', '--version', action='store_true', help='Print the version number of xcmake and exit')
	return parser

def build_parsers():
	parser = create_parser(add_help=True)

	subparser, subparsers = add_subparsers(None)

	parser_help = create_parser(add_help=False)
	subparser_help, subparsers_help = add_subparsers(parser_help)

	parser.set_defaults(subparsers=subparsers, subparser=subparser, subparser_help=subparser_help)
	return (parser, subparser, subparser_help)

def split_arguments(args):
	if not args:
		return ([], [])
	sub_arg_idx = 0
	for arg in args:
		if arg[0] != '-':
			break
		sub_arg_idx += 1
	return (args[:sub_arg_idx], args[sub_arg_idx:])

def parse_arguments(parser, subparser, args):
	args, sub_args = split_arguments(args)

	parser.parse_args(args, XCMAKE)
	if sub_args:
		options, pass_args = subparser.parse_known_args(sub_args)
	else:
		options = None
		pass_args = []

	return (options, pass_args)

def main():
	(parser, subparser, subparser_help) = build_parsers()

	argv = sys.argv[1:]
	if not argv:
		subparser_help.print_help()
		sys.exit(0);

	options, pass_args = parse_arguments(parser, subparser, argv)

	if XCMAKE.help:
		subparser_help.print_help()
	elif XCMAKE.version:
		print_version()
	elif not options or not options.func:
		subparser_help.print_help()
	else:
		if XCMAKE.directory:
			os.chdir(XCMAKE.directory)
		options.func(options, pass_args)

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

