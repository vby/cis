#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil

CMAKE_COMMAND = os.environ.get('XCMAKE_CMAKE_COMMAND') or 'cmake'
CTEST_COMMAND = os.environ.get('XCMAKE_CTEST_COMMAND') or 'ctest'
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'

class XCMAKE:
	NAME = 'XCMake'
	VERSION='1.1.0'
	DESCRIPTION = 'XCMake - CMake command-line helper'
	PROG = os.path.basename(sys.argv[0])
	COMMAND = os.path.abspath(sys.argv[0])
	BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build'
	SEARCH_CMAKELISTS = True
	CMAKE_MIN_VERSION = '3.3'

class XCMakeError(Exception):
	pass

def print_color(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

def argument_text_escape(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def call_subprocess(args, get_output=False, echo_command=True):
	if echo_command:
		print_color(' '.join((argument_text_escape(arg) for arg in args)), attrs='green,bold')
	sys.stdout.flush()
	sys.stderr.flush()
	if get_output:
		return subprocess.check_output(args)
	else:
		subprocess.check_call(args)

def find_cmakelists_directory(cdir = os.getcwd()):
	while not os.path.exists(os.path.join(cdir, CMAKELISTS)):
		cdir, f = os.path.split(cdir)
		if not f:
			return None
	return os.path.normpath(cdir)

def get_cmakelists_directory(cdir = None):
	if not cdir:
		cdir = getattr(get_cmakelists_directory, 'cmakelists_dir', None)
		if cdir:
			return cdir
		cdir = os.getcwd()
	fcdir = find_cmakelists_directory(cdir)
	if not fcdir:
		raise XCMakeError('Not a cmake project (or any of the parent directories): %s'%(CMAKELISTS))
	if not cdir:
		setattr(get_cmakelists_directory, 'cmakelists_dir', fcdir)
	return fcdir

def change_to_cmakelists_directory():
	cdir = get_cmakelists_directory()
	if cdir != cwd:
		os.chdir(cdir)
		cwd = cdir
	return cwd

def get_build_directory(cmakelists_dir = None):
	if not cmakelists_dir:
		cmakelists_dir = get_cmakelists_directory()
	return os.path.normpath(os.path.join(cmakelists_dir, XCMAKE.BUILD_DIR))

def get_cmakecache_path(build_dir = None):
	if not build_dir:
		build_dir = get_build_directory()
	return os.path.join(build_dir, CMAKECACHE)

def split_cmake_cache_entry(entry):
	nametype, value = entry.split('=')
	name_type = nametype.split(':')
	vtype = name_type[1].strip() if len(name_type) > 1 else None
	return (name_type[0].strip(), vtype, value.strip())

def find_cmake_cache_entries(name=None):
	if hasattr(find_cmake_cache_entries, 'entries'):
		entries = find_cmake_cache_entries.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		return entry[0] if entry else ''
	cmakecache = get_cmakecache_path() 
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(get_build_directory(), CMAKECACHE))
	entries = {}
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			ename, vtype, value = split_cmake_cache_entry(line)
			entries[ename] = (value, vtype)
	find_cmake_cache_entries.entries = entries
	return find_cmake_cache_entries(name)

def scratch(cwd, cmakelists):
	project_name = os.path.basename(cwd)
	with open(cmakelists, 'w') as f:
		f.write(
'''# Generated by %(xcmake_name)s.
cmake_minimum_required(VERSION %(min_ver)s)\n
project(%(proj)s CXX)\n
file(GLOB sources LIST_DIRECTORIES false "*.cpp")
file(GLOB_RECURSE src_sources LIST_DIRECTORIES false "src/*.cpp")
list(APPEND sources ${src_sources})\n
add_executable(%(proj)s ${sources})\n
#add_library(%(proj)s STATIC ${sources})
#add_library(%(proj)s SHARED ${sources})\n
target_include_directories(%(proj)s PUBLIC include ${include_dirs})
target_link_libraries(%(proj)s ${libs})\n
install(TARGETS %(proj)s DESTINATION bin)\n
#install(TARGETS %(proj)s DESTINATION lib)
#install(DIRECTORY src/ include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n
'''		%{
			'xcmake_name': XCMAKE.NAME,
			'min_ver': XCMAKE.CMAKE_MIN_VERSION,
			'proj': project_name,
		})

def execute_process(command, args=None, pass_args=None, get_output=False, echo_command=True):
	argv = [command]
	if args:
		argv += args
	if pass_args:
		argv += pass_args
	return call_subprocess(argv, get_output, echo_command)

def get_cmake_generators():
	generators = []
	try:
		cmake_help_text = execute_process(('-h',), with_pass_argv=False, output=True, echo=False).decode('utf8')
		g = False 
		for line in cmake_help_text.splitlines():
			if g:
				generators.append(line)
			elif line.lstrip().startswith('Generators'):
				g = True
	except Exception as e:
		pass
	return generators

def print_version():
	sys.stdout.write('%s version %s\n\n%s maintained and supported by vby (Github.com/vby).\n'
			%(XCMAKE.PROG, XCMAKE.VERSION, XCMAKE.NAME)
		)

def append_build_config(sub_args, cmake_args):
	if sub_args.config:
		cmake_args.extend(('--config', sub_args.config)) 
	else:
		build_type = find_cmake_cache_entries('CMAKE_BUILD_TYPE')
		if build_type:
			cmake_args.extend(('--config', build_type)) 

def append_native_argument(args, arg, p = None):
	args_dict = getattr(append_native_argument, 'args_dict', None)
	if args_dict:
		f = args_dict[arg]
		if isinstance(f, str):
			args.append(f)
		elif isinstance(f, tuple):
			args.extend(f)
		else:
			args.append(f(p))
		return
	args_dict = {}
	gen = find_cmake_cache_entries('CMAKE_GENERATOR')
	if gen and gen.find('Visual Studio') >= 0:
		args_dict['property'] = lambda x: '/p:%s'%(x)
		args_dict['jobs'] = lambda x: '/m' if x == None else '/m:%d'%(x)
		args_dict['trace'] = '/v:d'
		args_dict['debug'] = lambda x: '/v:d' if x != 'a' else '/v:diag'
		args_dict['silent'] = ('/nologo', '/v:q')
	else:
		args_dict['property'] = lambda x: '%s'%(x)
		args_dict['jobs'] = lambda x: '-j' if x == None else '-j%d'%(x)
		args_dict['trace'] = '--trace' 
		args_dict['debug'] = lambda x: '-d' if x == None else '--debug=%s'%(x)
		args_dict['silent'] = '-s'
	append_native_argument.args_dict = args_dict
	return append_native_argument(args, arg, p)

def make_arguments_to_native_arguments(sub_args):
	args = []
	# properties in targets
	if sub_args.target:
		targets = []
		for target in sub_args.target:
			if '=' in target:
				append_native_argument(args, 'property', target)
			else:
				targets.append(target)
		sub_args.target = targets
	# -j --jobs
	if sub_args.jobs == None: 
		append_native_argument(args, 'jobs')
	elif sub_args.jobs >= 0:
		append_native_argument(args, 'jobs', sub_args.jobs)
	# --trace
	if sub_args.trace:
		append_native_argument(args, 'trace')
	# -d --deubg
	if sub_args.d or sub_args.debug != False:
		if not sub_args.debug:
			append_native_argument(args, 'debug')
		else:
			append_native_argument(args, 'debug', sub_args.debug)
	# -s --silent
	if sub_args.silent:
		append_native_argument(args, 'silent')
	return args

def subcommand_init(args, sub_args, pass_args):
	cwd = os.getcwd()
	cmakelists = os.path.join(cwd, CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		scratch(cwd, cmakelists)
	except:
		os.remove(cmakelists)
		raise

def subcommand_cmake(args, sub_args, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	cmake_args = ['-H' + cmakelists_dir, '-B' + build_dir]
	execute_process(args.cmake_command, cmake_args, pass_args)

def subcommand_build(args, sub_args, pass_args):
	build_dir = get_build_directory()
	cmakecache = get_cmakecache_path(build_dir)
	if not os.path.exists(cmakecache):
		subcommand_cmake(args, [], None)
	cmake_args = ['--build', build_dir]
	append_build_config(sub_args, cmake_args)
	execute_process(args.cmake_command, cmake_args, pass_args)

def subcommand_make(args, sub_args, pass_args):
	native_args = make_arguments_to_native_arguments(sub_args)
	if native_args:
		pass_args.append('--')
		pass_args.extend(native_args)
	if not sub_args.target:
		subcommand_build(args, sub_args, pass_args)
		return
	targets = set()
	for target in sub_args.target:
		if target in targets:
			continue
		targets.add(target)
		subcommand_build(args, sub_args, ['--target', target] + pass_args)

def subcommand_ctest(args, sub_args, pass_args):
	cmake_args = ['-E', 'chdir', get_build_directory(), args.ctest_command, '--force-new-ctest-process']
	execute_process(args.cmake_command, cmake_args, pass_args)

def subcommand_clean(args, sub_args, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	if not os.path.exists(build_dir):
		return
	if sub_args.all:
		if cmakelists_dir == build_dir:
			raise XCMakeError('The build directory "%s" contains %s.'%(build_dir, CMAKELISTS))
		execute_process(args.cmake_command, ['-E', 'remove_directory', build_dir])
	else:
		cmakecache = get_cmakecache_path() 
		if os.path.exists(cmakecache):
			os.remove(cmakecache)

def subcommand_status(args, pass_args, status=False):
	internal_entries = []
	cmake_entries = []
	entries = []
	for name, (value, vtype) in find_cmake_cache_entries().items():
		if not value:
			continue
		if vtype == 'INTERNAL':
			if not status or (name.startswith('CMAKE_GENERATOR') or name.endswith('_COMMAND') or name.endswith('_DIR') or name.endswith('_DIRECTORY')):
				internal_entries.append((name, value))
			continue
		if vtype == 'PATH' or vtype == 'FILEPATH':
			if value.endswith('-NOTFOUND'):
				continue
		if name.startswith('CMAKE_'):
			if status:
				if name.endswith('_PREFIX'):
					cmake_entries.append((name, vtype, value))
			else:
				cmake_entries.append((name, vtype, value))
		else:
			if not status:
				entries.append((name, vtype, value))
	print_color('INTERNAL:', attrs='cyan')
	for name, value in sorted(internal_entries):
		sys.stdout.write('%s=%s\n'%(name, value))
	if cmake_entries:
		print_color('EXTERNAL-CMAKE:', attrs='cyan')
		for name, vtype, value in sorted(cmake_entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))
	if entries:
		print_color('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\nSpecify --help or -h or /? for usage\n'%(self.prog, message))
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

def add_init_parser(subparsers):
	parser = subparsers.add_parser('init', help='Create a %s template'%(CMAKELISTS))
	parser.set_defaults(func=subcommand_init)

def add_cmake_parser(subparsers):
	parser = subparsers.add_parser('cmake', help='Run cmake')
	parser.set_defaults(func=subcommand_cmake)

def add_build_parser(subparsers):
	parser = subparsers.add_parser('build', help='Run cmake --build')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')
	parser.set_defaults(func=subcommand_build)

def add_make_parser(subparsers):
	parser = subparsers.add_parser('make', help='Run cmake --build by make interface')
	parser.set_defaults(func=subcommand_make)
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')
	
def add_ctest_parser(subparsers):
	parser = subparsers.add_parser('ctest', help='Run ctest')
	parser.set_defaults(func=subcommand_ctest)

def add_clean_parser(subparsers):
	parser = subparsers.add_parser('clean', help='Clean cmake cache')
	parser.set_defaults(func=subcommand_clean)
	parser.add_argument('-a', '--all', action='store_true', help='Remove the BUILD_DIR')

def add_status_parser(subparsers):
	parser = subparsers.add_parser('status', help='Show cmake cache entries')
	parser.set_defaults(func=subcommand_status)

def add_subparsers(parser):
	if parser: 
		subparser = ArgumentParser(parents=(parser,))
	else:
		subparser = ArgumentParser()
	subparsers = subparser.add_subparsers(title='subcommands')

	add_init_parser(subparsers)
	add_cmake_parser(subparsers)
	add_build_parser(subparsers)
	add_make_parser(subparsers)
	add_ctest_parser(subparsers)
	add_clean_parser(subparsers)
	add_status_parser(subparsers)

	return subparser

def create_parser(add_help):
	parser = ArgumentParser(prog=XCMAKE.PROG, 
		description=XCMAKE.DESCRIPTION,
		add_help=False)
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('--cmake-command', action=PathOrNameAction, default=CMAKE_COMMAND, help='Default "%s"'%(CMAKE_COMMAND))
	parser.add_argument('--ctest-command', action=PathOrNameAction, default=CTEST_COMMAND, help='Default "%s"'%(CTEST_COMMAND))
	if add_help:
		parser.add_argument('-h', '--help', action='store_true', help='Print this message and exit')
	parser.add_argument('-v', '--version', action='store_true', help='Print the version number of xcmake and exit')
	return parser

def build_parsers():
	parser = create_parser(add_help=True)

	subparser = add_subparsers(None)

	parser_help = create_parser(add_help=False)
	subparser_help = add_subparsers(parser_help)

	return (parser, subparser, subparser_help)

def split_arguments(args):
	if not args:
		return ([], [])
	sub_arg_idx = 0
	for arg in args:
		if arg[0] != '-':
			break
		sub_arg_idx += 1
	return (args[:sub_arg_idx], args[sub_arg_idx:])

def parse_arguments(parser, subparser, args):
	args, sub_args = split_arguments(args)

	args = parser.parse_args(args)
	if sub_args:
		sub_args, pass_args = subparser.parse_known_args(sub_args)
	else:
		sub_args = None
		pass_args = []

	return (args, sub_args, pass_args)

def main():
	(parser, subparser, subparser_help) = build_parsers()

	argv = sys.argv[1:]
	if not argv:
		subparser_help.print_help()
		sys.exit(0);

	args, sub_args, pass_args = parse_arguments(parser, subparser, argv)

	if args.help:
		subparser_help.print_help()
	elif args.version:
		print_version()
	elif not sub_args.func:
		subparser_help.print_help()
	else:
		if args.directory:
			os.chdir(args.directory)
		sub_args.func(args, sub_args, pass_args)

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

