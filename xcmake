#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil

CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'
CMAKE_MIN_VERSION = '2.6'

XCMAKE_VERSION='1.0.0'
XCMAKE_BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build_xcmake'
XCMAKE_INSTALL_DIR = 'out'
XCMAKE_PROG = 'xcmake'
XCMAKE_DESCRIPTION = 'XCMake - Make frontend for cmake'

XCMAKE_ARGS = None

class XCMakeError(Exception):
	pass

def echo_color(text, color=None, bold=False, newline=True):
	cmake_argv = ['cmake', '-E', 'cmake_echo_color']
	if color:
		cmake_argv.append('--%s'%(color))
	if bold:
		cmake_argv.append('--bold')
	if not newline:
		cmake_argv.append('--no-newline')
	cmake_argv.append(text)
	sys.stdout.flush()
	sys.stderr.flush()
	subprocess.check_call(cmake_argv)

def subp_escape(arg):
	if not arg or arg.find(' ') >= 0:
		return '"%s"'%(arg)
	return arg

def subp_check_call(args, show=True):
	if show:
		echo_color(' '.join((subp_escape(arg) for arg in args)), color='green', bold=True)
	else:
		sys.stdout.flush()
		sys.stderr.flush()
	subprocess.check_call(args)

def do_scratch(cmakelists):
	project_name = os.path.basename(XCMAKE_ARGS.directory)
	with open(cmakelists, 'w') as f:
		f.write('# Generated by XCMAKE.\n')
		f.write('cmake_minimum_required(VERSION %s)\n\n'%(CMAKE_MIN_VERSION))
		f.write('project(%s)\n\n'%(project_name))
		f.write('#set(CMAKE_VERBOSE_MAKEFILE on)\n\n')
		f.write('include_directories(include)\n\n')
		f.write('file(GLOB sources "src/*.cpp")\n\n')
		f.write('add_executable(%s ${sources})\n\n'%(project_name))
		f.write('#target_link_libraries(%s ${libs})\n\n'%(project_name))
		f.write('#add_library(%s_shared SHARED ${sources})\n\n'%(project_name))
		f.write('#add_library(%s_static STATIC ${sources})\n\n'%(project_name))
		f.write('set(CMAKE_INSTALL_PREFIX "%s")\n\n'%(os.path.join(XCMAKE_ARGS.build_dir, XCMAKE_INSTALL_DIR).replace('\\', '/')))
		f.write('install(TARGETS %s DESTINATION bin)\n\n'%(project_name))
		f.write('install(DIRECTORY include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n\n')
		f.write('#install(TARGETS %s_shared DESTINATION lib)\n\n'%(project_name))
		f.write('#install(TARGETS %s_static DESTINATION lib)\n\n'%(project_name))

def do_cmake(args=None, native_args=None, with_hyphen_argv=True):
	cmake_argv = ['cmake']
	if args:
		cmake_argv += args
	if with_hyphen_argv and XCMAKE_ARGS.hyphen_argv:
		cmake_argv += XCMAKE_ARGS.hyphen_argv
	if native_args:
		if '--' not in cmake_argv:
			cmake_argv.append('--')
		cmake_argv += native_args
	subp_check_call(cmake_argv)

def find_cache_entry(name=None):
	try:
		entries = find_cache_entry.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		return entry[0] if entry else ''
	except:
		find_cache_entry.entries = {}
	cmakecache = os.path.join(XCMAKE_ARGS.build_dir, CMAKECACHE)
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(XCMAKE_ARGS.build_dir, CMAKECACHE))
	entries = find_cache_entry.entries
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			entry, value = line.split('=')
			ename, vtype = entry.split(':')
			entries[ename] = (value, vtype)
	return find_cache_entry(name)


def cmake_generators():
	generators = []
	try:
		cmake_help_text = subprocess.check_output(['cmake', '-h']).decode('utf8')
		g = False 
		for line in cmake_help_text.splitlines():
			if g:
				generators.append(line)
			elif line.lstrip().startswith('Generators'):
				g = True
	except:
		pass
	return generators

def command_version():
	sys.stdout.write('%s version %s\n\n'%(XCMAKE_PROG, XCMAKE_VERSION))
	subp_check_call(['cmake', '--version'], show=False)

def command_scratch():
	cmakelists = os.path.abspath(CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		do_scratch(cmakelists)
	except:
		os.remove(cmakelists)
		raise

def command_cmake():
	do_cmake(['-E', 'chdir', XCMAKE_ARGS.build_dir, 'cmake'])

def command_update(with_hyphen_argv=True):
	argv = ['-H' + XCMAKE_ARGS.directory, '-B' + XCMAKE_ARGS.build_dir]
	if XCMAKE_ARGS.U:
		for u in XCMAKE_ARGS.U:
			argv.append('-D' + u)
	if XCMAKE_ARGS.D:
		for d in XCMAKE_ARGS.D:
			argv.append('-D' + d)
	if XCMAKE_ARGS.generator != None:
		argv += ['-G', XCMAKE_ARGS.generator]
	if XCMAKE_ARGS.toolset != None:
		argv += ['-T', XCMAKE_ARGS.toolset]
	if XCMAKE_ARGS.platform != None:
		argv += ['-A', XCMAKE_ARGS.platform]
	if XCMAKE_ARGS.trace_expand:
		argv.append('--trace-expand')
	elif XCMAKE_ARGS.trace:
		argv.append('--trace')
	if XCMAKE_ARGS.debug != False:
		argv.append('--debug-output')
	do_cmake(argv, with_hyphen_argv=with_hyphen_argv)

def do_build_target(target=None, native_args=None):
	argv = ['--build', XCMAKE_ARGS.build_dir]
	if target:
		argv += ['--target', target]
	do_cmake(argv, native_args=native_args)

def build_native_arg(arg):
	try:
		return build_native_arg.args.get(arg)
	except:
		build_native_arg.args = {}
	args = build_native_arg.args
	gen = find_cache_entry('CMAKE_GENERATOR')
	if gen and gen.find('Visual Studio') >= 0:
		args['property'] = '/p:%s'
		args['jobs'] = ('/m', '/m:%d')
		args['trace'] = '/v:d' 
		args['debug'] = ('/v:diag', lambda x: '/v:diag')
		args['silent'] = ('/nologo', '/v:q')
	else:
		args['property'] = '%s'
		args['jobs'] = ('-j', '-j%d')
		args['trace'] = '--trace' 
		args['debug'] = ('-d', lambda x: '--debug=%s'%(x))
		args['silent'] = ('-s',)
	return build_native_arg(arg)

def build_native_args():
	args = []
	# properties in targets
	if XCMAKE_ARGS.target:
		targets = []
		for target in XCMAKE_ARGS.target:
			if '=' in target:
				args.append(build_native_arg('property')%(target))
			else:
				targets.append(target)
		XCMAKE_ARGS.target = targets
	# -j --jobs
	if XCMAKE_ARGS.jobs == None: 
		args.append(build_native_arg('jobs')[0])
	elif XCMAKE_ARGS.jobs >= 0:
		args.append(build_native_arg('jobs')[1]%(XCMAKE_ARGS.jobs))
	# --trace
	if XCMAKE_ARGS.trace:
		args.append(build_native_arg('trace'))
	# -d --deubg
	if XCMAKE_ARGS.debug != False:
		if XCMAKE_ARGS.debug == '':
			args.append(build_native_arg('debug')[0])
		else:
			args.append(build_native_arg('debug')[1](XCMAKE_ARGS.debug))
	# -s --silent
	if XCMAKE_ARGS.silent:
		args.extend(build_native_arg('silent'))
	return args

def command_build(update=True):
	if update and (not os.path.exists(XCMAKE_ARGS.build_dir) or not os.listdir(XCMAKE_ARGS.build_dir)):
		command_update(with_hyphen_argv=False)
	native_args = build_native_args()
	if not XCMAKE_ARGS.target:
		return do_build_target(None, native_args)
	targets = set()
	for target in XCMAKE_ARGS.target:
		if target in targets:
			continue
		targets.add(target)
		do_build_target(target, native_args)

def command_update_build():
	command_update(with_hyphen_argv=False)
	command_build(update=False)

def command_clean():
	if os.path.exists(XCMAKE_ARGS.build_dir):
		if XCMAKE_ARGS.directory == XCMAKE_ARGS.build_dir:
			raise XCMakeError('The build directory "%s" is source directory.'%(XCMAKE_ARGS.build_dir))
	subp_check_call(['cmake', '-E', 'remove_directory', XCMAKE_ARGS.build_dir])

def command_show(status=False):
	internal_entries = []
	cmake_entries = []
	entries = []
	for name, (value, vtype) in find_cache_entry().items():
		if not value:
			continue
		if vtype == 'INTERNAL':
			if not status or (name.startswith('CMAKE_GENERATOR') or name.endswith('_COMMAND') or name.endswith('_DIR') or name.endswith('_DIRECTORY')):
				internal_entries.append((name, value))
			continue
		if vtype == 'PATH' or vtype == 'FILEPATH':
			if value.endswith('-NOTFOUND'):
				continue
		if name.startswith('CMAKE_'):
			if status:
				if name.endswith('_PREFIX'):
					cmake_entries.append((name, vtype, value))
			else:
				cmake_entries.append((name, vtype, value))
		else:
			if not status:
				entries.append((name, vtype, value))
	echo_color('INTERNAL:', color='cyan')
	for name, value in sorted(internal_entries):
		sys.stdout.write('%s=%s\n'%(name, value))
	if cmake_entries:
		echo_color('EXTERNAL-CMAKE:', color='cyan')
		for name, vtype, value in sorted(cmake_entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))
	if entries:
		echo_color('EXTERNAL:', color='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

def command_status():
	command_show(status=True)

def print_help(parser, fd=sys.stdout):
	parser.print_help()
	fd.write('\nGenerators\n%s\n'%('\n'.join(cmake_generators())))

def command_help(parser):
	print_help(parser)
	sys.exit(0)

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\n\n'%(self.prog, message))
		print_help(self, sys.stderr)
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(values))

def adjust_arguments(parser, hyphen_argv):
	# show help
	if XCMAKE_ARGS.help:
		command_help(parser)
	# chdir to --directory
	if XCMAKE_ARGS.directory:
		os.chdir(XCMAKE_ARGS.directory)
	else:
		XCMAKE_ARGS.directory = os.getcwd()
	# --debug
	if XCMAKE_ARGS.debug:
		if 'n' in XCMAKE_ARGS.debug:
			XCMAKE_ARGS.debug = False
			XCMAKE_ARGS.d = False
	if XCMAKE_ARGS.debug == None or (XCMAKE_ARGS.d and not XCMAKE_ARGS.debug):
		XCMAKE_ARGS.debug = ''
	# set --trace for --trace-expand
	if XCMAKE_ARGS.trace_expand:
		XCMAKE_ARGS.trace = True
	# --silent
	if XCMAKE_ARGS.silent:
		XCMAKE_ARGS.debug = False
		XCMAKE_ARGS.trace = False
		XCMAKE_ARGS.trace_expand = False
	# set default --build-dir
	if not XCMAKE_ARGS.build_dir:
		XCMAKE_ARGS.build_dir = os.path.abspath(XCMAKE_BUILD_DIR)
	# set --update for -G -T -A -D -U
	if not XCMAKE_ARGS.update:
		if XCMAKE_ARGS.generator != None or XCMAKE_ARGS.toolset != None or XCMAKE_ARGS.platform != None or XCMAKE_ARGS.D or XCMAKE_ARGS.U:
			XCMAKE_ARGS.update = True
	# set -- //
	setattr(XCMAKE_ARGS, 'hyphen_argv', hyphen_argv)

def split_arguments(argv):
	args = [arg if arg != '//' else '--' for arg in argv]
	hyphen_arg_idx = 0
	for arg in args:
		hyphen_arg_idx += 1
		if arg == '--cmake' or arg == '--':
			break
	return (args[:hyphen_arg_idx], args[hyphen_arg_idx:]) 

def parse_arguments(argv):
	parser = ArgumentParser(prog=XCMAKE_PROG, 
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description=XCMAKE_DESCRIPTION, 
		add_help=False)
	# make
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-v', '--version', action='store_true', help='Display version and exit')
	parser.add_argument('-h', '--help', action='store_true', help='Print this message and exit')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print lots of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	# cmake extend
	parser.add_argument('--trace-expand', action='store_true', help='Trace with variable expansion')
	# common
	parser.add_argument('-B', '--build-dir', action=PathAction, help='Default "%s"(base on -C)'%(XCMAKE_BUILD_DIR))
	# command scratch
	parser.add_argument('--scratch', action='store_true', help='Create a %s template'%(CMAKELISTS))
	# command update
	parser.add_argument('--update', action='store_true', help='Create or update cmake cache')
	parser.add_argument('-G', '--generator', help='Specify a build system generator')
	parser.add_argument('-T', '--toolset', help='Specify toolset name if supported by GENERATOR')
	parser.add_argument('-A', '--platform', help='Specify platform name if supported by GENERATOR')
	# BUG of parser: '[' in metavar
	parser.add_argument('-D', metavar='<var>{:<type>}=<value>', action='append', help='Create a cmake cache entry')
	parser.add_argument('-U', metavar='<globbing_expr>', action='append', help='Remove matching entries from CMake cache')
	# command build
	parser.add_argument('--build', action='store_true', help='Make targets')
	# command clean
	parser.add_argument('--clean', action='store_true', help='Remove BUILD_DIR')
	# command status
	parser.add_argument('--status', action='store_true', help='Show cache status')
	# command show
	parser.add_argument('--show', action='store_true', help='Show cache entries')
	# command cmake
	parser.add_argument('--cmake', action='store_true', help='Run cmake in BUILD_DIR')
	# only for help
	parser.add_argument('--', dest='hyphen_argv', metavar='or //', help='Pass remaining options to cmake')

	global XCMAKE_ARGS

	args, hyphen_argv = split_arguments(argv)

	XCMAKE_ARGS = parser.parse_args(args)

	adjust_arguments(parser, hyphen_argv)

def main():
	parse_arguments(sys.argv[1:])

	#print(XCMAKE_ARGS)
	if XCMAKE_ARGS.version:
		return command_version()
	if XCMAKE_ARGS.cmake:
		return command_cmake()
	if XCMAKE_ARGS.status:
		return command_status()
	if XCMAKE_ARGS.show:
		return command_show()
	if XCMAKE_ARGS.scratch:
		return command_scratch()
	if XCMAKE_ARGS.clean:
		return command_clean()
	if XCMAKE_ARGS.update and XCMAKE_ARGS.build:
		return command_update_build()
	if XCMAKE_ARGS.update:
		return command_update()
	return command_build()

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

