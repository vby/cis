#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil
import re

CMAKE_COMMAND = os.environ.get('XCMAKE_CMAKE_COMMAND') or 'cmake'
CTEST_COMMAND = os.environ.get('XCMAKE_CTEST_COMMAND') or 'ctest'
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'

class XCMAKE:
	NAME = 'XCMake'
	VERSION='1.1.0'
	DESCRIPTION = 'XCMake - CMake command-line helper'
	PROG = os.path.basename(sys.argv[0])
	COMMAND = os.path.abspath(sys.argv[0])
	BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build'
	SEARCH_CMAKELISTS = True
	CMAKE_MIN_VERSION = '3.3'

VisualStudioVersionMap = {
	7: '7 .NET 2003',
	8: '8 2005',
	9: '9 2008',
	2002: '.NET 2002', # Removed since CMake 3.6
	2003: '7 .NET 2003',
	2005: '8 2005',
	2008: '9 2008',
	2010: '10',
	2012: '11',
	2013: '12',
	2015: '14',
	2017: '15',
}

VisualStudioArchMap = {
	'x86': '',
	'x64': 'Win64',
	'x86_64': 'Win64',
	'arm': 'ARM',
	'ia64': 'IA64',
}

class XCMakeError(Exception):
	pass

def print_color(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

def argument_text_escape(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def call_subprocess(args, get_output=False, echo_command=True):
	if echo_command:
		print_color(' '.join((argument_text_escape(arg) for arg in args)), attrs='green,bold')
	sys.stdout.flush()
	sys.stderr.flush()
	if get_output:
		return subprocess.check_output(args)
	else:
		subprocess.check_call(args)

def find_cmakelists_directory(cdir = os.getcwd()):
	while not os.path.exists(os.path.join(cdir, CMAKELISTS)):
		cdir, f = os.path.split(cdir)
		if not f:
			return None
	return os.path.normpath(cdir)

def get_cmakelists_directory(cdir = None):
	if not cdir:
		cdir = getattr(get_cmakelists_directory, 'cmakelists_dir', None)
		if cdir:
			return cdir
		cdir = os.getcwd()
	fcdir = find_cmakelists_directory(cdir)
	if not fcdir:
		raise XCMakeError('Not a cmake project (or any of the parent directories): %s'%(CMAKELISTS))
	if not cdir:
		setattr(get_cmakelists_directory, 'cmakelists_dir', fcdir)
	return fcdir

def change_to_cmakelists_directory():
	cdir = get_cmakelists_directory()
	if cdir != cwd:
		os.chdir(cdir)
		cwd = cdir
	return cwd

def get_build_directory(cmakelists_dir = None):
	if not cmakelists_dir:
		cmakelists_dir = get_cmakelists_directory()
	return os.path.normpath(os.path.join(cmakelists_dir, XCMAKE.BUILD_DIR))

def get_cmakecache_path(build_dir = None):
	if not build_dir:
		build_dir = get_build_directory()
	return os.path.join(build_dir, CMAKECACHE)

def split_cmake_cache_entry(entry):
	nametype, value = entry.split('=')
	name_type = nametype.split(':')
	vtype = name_type[1].strip() if len(name_type) > 1 else None
	return (name_type[0].strip(), vtype, value.strip())

def find_cmake_cache_entries(name=None, with_type=False):
	if hasattr(find_cmake_cache_entries, 'entries'):
		entries = find_cmake_cache_entries.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		if not with_type:
			return entry[0] if entry else ''
		else:
			return entry
	cmakecache = get_cmakecache_path() 
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(get_build_directory(), CMAKECACHE))
	entries = {}
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			ename, vtype, value = split_cmake_cache_entry(line)
			entries[ename] = (value, vtype)
	find_cmake_cache_entries.entries = entries
	return find_cmake_cache_entries(name, with_type)

def scratch(cwd, cmakelists):
	project_name = os.path.basename(cwd)
	with open(cmakelists, 'w') as f:
		f.write(
'''# Generated by %(xcmake_name)s.
cmake_minimum_required(VERSION %(min_ver)s)\n
project(%(proj)s CXX)\n
file(GLOB sources LIST_DIRECTORIES false "*.cpp")
file(GLOB_RECURSE src_sources LIST_DIRECTORIES false "src/*.cpp")
list(APPEND sources ${src_sources})\n
add_executable(%(proj)s ${sources})\n
#add_library(%(proj)s STATIC ${sources})
#add_library(%(proj)s SHARED ${sources})\n
target_include_directories(%(proj)s PUBLIC include ${include_dirs})
target_link_libraries(%(proj)s ${libs})\n
install(TARGETS %(proj)s DESTINATION bin)\n
#install(TARGETS %(proj)s DESTINATION lib)
#install(DIRECTORY src/ include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n
'''		%{
			'xcmake_name': XCMAKE.NAME,
			'min_ver': XCMAKE.CMAKE_MIN_VERSION,
			'proj': project_name,
		})

def execute_process(command, args=None, pass_args=None, get_output=False, echo_command=True):
	argv = [command]
	if args:
		argv += args
	if pass_args:
		for arg in pass_args:
			if arg.startswith('++'):
				arg = '--' + arg[2:]
			elif arg[0] == '+':
				arg = '-' + arg[1:]
			argv.append(arg) 
	return call_subprocess(argv, get_output, echo_command)

def get_cmake_generators():
	generators = []
	try:
		cmake_help_text = execute_process(('-h',), with_pass_argv=False, output=True, echo=False).decode('utf8')
		g = False 
		for line in cmake_help_text.splitlines():
			if g:
				generators.append(line)
			elif line.lstrip().startswith('Generators'):
				g = True
	except Exception as e:
		pass
	return generators

def print_version():
	sys.stdout.write('%s version %s\n\n%s maintained and supported by vby (Github.com/vby).\n'
			%(XCMAKE.PROG, XCMAKE.VERSION, XCMAKE.NAME)
		)

def append_build_config(sub_args, cmake_args):
	if not sub_args:
		return
	if sub_args.config:
		cmake_args.extend(('--config', sub_args.config)) 
	else:
		build_type = find_cmake_cache_entries('CMAKE_BUILD_TYPE')
		if build_type:
			cmake_args.extend(('--config', build_type)) 

def append_native_argument(args, arg, p = None):
	args_dict = getattr(append_native_argument, 'args_dict', None)
	if args_dict:
		f = args_dict[arg]
		if isinstance(f, str):
			args.append(f)
		elif isinstance(f, tuple):
			args.extend(f)
		else:
			args.append(f(p))
		return
	args_dict = {}
	gen = find_cmake_cache_entries('CMAKE_GENERATOR')
	if gen and gen.find('Visual Studio') >= 0:
		args_dict['property'] = lambda x: '/p:%s'%(x)
		args_dict['jobs'] = lambda x: '/m' if x == None else '/m:%d'%(x)
		args_dict['trace'] = '/v:d'
		args_dict['debug'] = lambda x: '/v:d' if x != 'a' else '/v:diag'
		args_dict['silent'] = ('/nologo', '/v:q')
	else:
		args_dict['property'] = lambda x: '%s'%(x)
		args_dict['jobs'] = lambda x: '-j' if x == None else '-j%d'%(x)
		args_dict['trace'] = '--trace' 
		args_dict['debug'] = lambda x: '-d' if x == None else '--debug=%s'%(x)
		args_dict['silent'] = '-s'
	append_native_argument.args_dict = args_dict
	return append_native_argument(args, arg, p)

def make_arguments_to_native_arguments(sub_args):
	args = []
	# properties in targets
	if sub_args.target:
		targets = []
		for target in sub_args.target:
			if '=' in target:
				append_native_argument(args, 'property', target)
			else:
				targets.append(target)
		sub_args.target = targets
	# -j --jobs
	if sub_args.jobs == None: 
		append_native_argument(args, 'jobs')
	elif sub_args.jobs >= 0:
		append_native_argument(args, 'jobs', sub_args.jobs)
	# --trace
	if sub_args.trace:
		append_native_argument(args, 'trace')
	# -d --deubg
	if sub_args.d or sub_args.debug != False:
		if not sub_args.debug:
			append_native_argument(args, 'debug')
		else:
			append_native_argument(args, 'debug', sub_args.debug)
	# -s --silent
	if sub_args.silent:
		append_native_argument(args, 'silent')
	return args

def subcommand_init(args, sub_args, pass_args):
	cwd = os.getcwd()
	cmakelists = os.path.join(cwd, CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		scratch(cwd, cmakelists)
	except:
		os.remove(cmakelists)
		raise

# sub_args can be None
def subcommand_cmake(args, sub_args, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	cmake_args = ['-H' + cmakelists_dir, '-B' + build_dir]
	if sub_args and sub_args.G:
		m = re.match('^[vV][sS]\s*(\d+)(.*)', sub_args.G)
		if m:
			ver = m.group(1)
			ver = VisualStudioVersionMap.get(int(ver), ver)
			arch = m.group(2).strip()
			arch = VisualStudioArchMap.get(arch.lower(), arch)
			sub_args.G = 'Visual Studio %s%s'%(ver, ' ' + arch if arch else '')
		cmake_args.extend(('-G', sub_args.G))
	execute_process(args.cmake_command, cmake_args, pass_args)

# sub_args can be None
def subcommand_build(args, sub_args, pass_args):
	build_dir = get_build_directory()
	cmakecache = get_cmakecache_path(build_dir)
	if not os.path.exists(cmakecache):
		subcommand_cmake(args, None, None)
	cmake_args = ['--build', build_dir]
	append_build_config(sub_args, cmake_args)
	execute_process(args.cmake_command, cmake_args, pass_args)

def subcommand_make(args, sub_args, pass_args):
	native_args = make_arguments_to_native_arguments(sub_args)
	if native_args:
		pass_args.append('--')
		pass_args.extend(native_args)
	if not sub_args.target:
		subcommand_build(args, sub_args, pass_args)
		return
	targets = set()
	for target in sub_args.target:
		if target in targets:
			continue
		targets.add(target)
		subcommand_build(args, sub_args, ['--target', target] + pass_args)

# sub_args can be None
def subcommand_ctest(args, sub_args, pass_args):
	cmake_args = ['-E', 'chdir', get_build_directory(), args.ctest_command]
	execute_process(args.cmake_command, cmake_args, pass_args)

def subcommand_clean(args, sub_args, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	if not os.path.exists(build_dir):
		return
	if sub_args.all:
		if cmakelists_dir == build_dir:
			raise XCMakeError('The build directory "%s" contains %s.'%(build_dir, CMAKELISTS))
		execute_process(args.cmake_command, ['-E', 'remove_directory', build_dir])
	elif sub_args.target:
		pass_args.extend(('--target', 'clean'))
		subcommand_build(args, None, pass_args) 
	else:
		cmakecache = get_cmakecache_path() 
		if os.path.exists(cmakecache):
			os.remove(cmakecache)

def subcommand_status(args, sub_args, pass_args):
	cmakelists_dir = get_cmakelists_directory()
	build_dir = get_build_directory(cmakelists_dir)
	sys.stdout.write('Source directory: %s\n'%(cmakelists_dir))
	sys.stdout.write('Binary directory: %s\n'%(build_dir))

def subcommand_show(args, sub_args, pass_args):
	if sub_args.name:
		name = sub_args.name
		entry = find_cmake_cache_entries(name, True)
		if not entry:
			raise XCMakeError('No cache entry "%s"'%(name))
		sys.stdout.write('%s:%s=%s\n'%(name, entry[1], entry[0]))
		return
	internal_entries = []
	entries = []
	for name, (value, vtype) in find_cmake_cache_entries().items():
		if sub_args.internal:
			if vtype == 'INTERNAL':
				internal_entries.append((name, value))
			continue
		if sub_args.external:
			if vtype != 'INTERNAL':
				entries.append((name, vtype, value))
			continue
		if sub_args.cmake:
			if name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if sub_args.non_cmake:
			if not name.startswith('CMAKE_'):
				entries.append((name, vtype, value))
			continue
		if vtype == 'INTERNAL':
			internal_entries.append((name, value))
		else:
			entries.append((name, vtype, value))
	if internal_entries:
		if not sub_args.internal:
			print_color('INTERNAL:', attrs='cyan')
		for name, value in sorted(internal_entries):
			sys.stdout.write('%s=%s\n'%(name, value))
	if entries:
		if not sub_args.external and not sub_args.cmake and not sub_args.non_cmake:
			print_color('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\nSpecify --help or -h or /? for usage\n'%(self.prog, message))
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))

def add_parser(subparsers, name, *args, **kw):
	parser = subparsers.add_parser(name, *args, **kw)
	func = globals()['subcommand_%s'%(name.replace('-', '_'))]
	parser.set_defaults(func=func)
	return parser

def add_init_parser(subparsers):
	parser = add_parser(subparsers, 'init', help='Create a %s template'%(CMAKELISTS))

def add_cmake_parser(subparsers):
	parser = add_parser(subparsers, 'cmake', help='Run cmake')
	parser.add_argument('-G', metavar='GENERATOR', help='Specify a build system generator')

def add_build_parser(subparsers):
	parser = add_parser(subparsers, 'build', help='Run cmake --build')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')

def add_make_parser(subparsers):
	parser = add_parser(subparsers, 'make', help='Run cmake --build by make interface')
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')
	
def add_ctest_parser(subparsers):
	parser = add_parser(subparsers, 'ctest', help='Run ctest')

def add_clean_parser(subparsers):
	parser = add_parser(subparsers, 'clean', help='Clean cmake cache')
	parser.add_argument('-a', '--all', action='store_true', help='Remove the BUILD_DIR')
	parser.add_argument('--target', action='store_true', help='Same as %s cmake build --target clean'%(XCMAKE.PROG))

def add_status_parser(subparsers):
	parser = add_parser(subparsers, 'status', help='Show the working tree status')

def add_show_parser(subparsers):
	parser = add_parser(subparsers, 'show', help='Show cmake cache entries')
	parser.add_argument('-N', '--name', help='Show cache entry named NAME')
	parser.add_argument('--internal', action='store_true', help='Only show cache entries with type INTERNAL')
	parser.add_argument('--external', action='store_true', help='Only show cache entries with non INTERNAL type')
	parser.add_argument('--cmake', action='store_true', help='Only show cache entries with "CMAKE_" prefix')
	parser.add_argument('--non-cmake', action='store_true', help='Only show cache entries with non "CMAKE_" prefix')

def add_subparsers(parser):
	if parser: 
		subparser = ArgumentParser(parents=(parser,))
	else:
		subparser = ArgumentParser()
	subparsers = subparser.add_subparsers(title='subcommands')

	add_init_parser(subparsers)
	add_cmake_parser(subparsers)
	add_build_parser(subparsers)
	add_make_parser(subparsers)
	add_ctest_parser(subparsers)
	add_clean_parser(subparsers)
	add_status_parser(subparsers)
	add_show_parser(subparsers)

	return subparser

def create_parser(add_help):
	parser = ArgumentParser(prog=XCMAKE.PROG, 
		description=XCMAKE.DESCRIPTION,
		add_help=False)
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('--cmake-command', action=PathOrNameAction, default=CMAKE_COMMAND, help='Default "%s"'%(CMAKE_COMMAND))
	parser.add_argument('--ctest-command', action=PathOrNameAction, default=CTEST_COMMAND, help='Default "%s"'%(CTEST_COMMAND))
	if add_help:
		parser.add_argument('-h', '--help', action='store_true', help='Print this message and exit')
	parser.add_argument('-v', '--version', action='store_true', help='Print the version number of xcmake and exit')
	return parser

def build_parsers():
	parser = create_parser(add_help=True)

	subparser = add_subparsers(None)

	parser_help = create_parser(add_help=False)
	subparser_help = add_subparsers(parser_help)

	return (parser, subparser, subparser_help)

def split_arguments(args):
	if not args:
		return ([], [])
	sub_arg_idx = 0
	for arg in args:
		if arg[0] != '-':
			break
		sub_arg_idx += 1
	return (args[:sub_arg_idx], args[sub_arg_idx:])

def parse_arguments(parser, subparser, args):
	args, sub_args = split_arguments(args)

	args = parser.parse_args(args)
	if sub_args:
		sub_args, pass_args = subparser.parse_known_args(sub_args)
	else:
		sub_args = None
		pass_args = []

	return (args, sub_args, pass_args)

def main():
	(parser, subparser, subparser_help) = build_parsers()

	argv = sys.argv[1:]
	if not argv:
		subparser_help.print_help()
		sys.exit(0);

	args, sub_args, pass_args = parse_arguments(parser, subparser, argv)

	if args.help:
		subparser_help.print_help()
	elif args.version:
		print_version()
	elif not sub_args.func:
		subparser_help.print_help()
	else:
		if args.directory:
			os.chdir(args.directory)
		sub_args.func(args, sub_args, pass_args)

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

