#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil

CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'
CMAKE_MIN_VERSION = '2.6'

XCMAKE_VERSION='1.0.0'
XCMAKE_BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build_xcmake'
XCMAKE_INSTALL_DIR = 'out'
XCMAKE_PROG = 'xcmake'
XCMAKE_DESCRIPTION = 'XCMake - Make frontend for cmake'

XCMAKE_ARGS = None

class XCMakeError(Exception):
	pass

def echo_color(text, color=None, bold=False, newline=True):
	cmake_argv = ['cmake', '-E', 'cmake_echo_color']
	if color:
		cmake_argv.append('--%s'%(color))
	if bold:
		cmake_argv.append('--bold')
	if not newline:
		cmake_argv.append('--no-newline')
	cmake_argv.append(text)
	sys.stdout.flush()
	sys.stderr.flush()
	subprocess.check_call(cmake_argv)

def subp_escape(arg):
	if not arg or arg.find(' ') >= 0:
		return '"%s"'%(arg)
	return arg

def subp_check_call(args, show=True):
	if show:
		echo_color(' '.join((subp_escape(arg) for arg in args)), color='green', bold=True)
	else:
		sys.stdout.flush()
		sys.stderr.flush()
	subprocess.check_call(args)

def do_scratch(cmakelists):
	project_name = os.path.basename(XCMAKE_ARGS.directory)
	with open(cmakelists, 'w') as f:
		f.write('# Generated by XCMAKE.\n')
		f.write('cmake_minimum_required(VERSION %s)\n\n'%(CMAKE_MIN_VERSION))
		f.write('project(%s)\n\n'%(project_name))
		f.write('#set(CMAKE_VERBOSE_MAKEFILE on)\n\n')
		f.write('include_directories(include)\n\n')
		f.write('file(GLOB sources "src/*.cpp")\n\n')
		f.write('add_executable(%s ${sources})\n\n'%(project_name))
		f.write('#target_link_libraries(%s ${libs})\n\n'%(project_name))
		f.write('#add_library(%s_shared SHARED ${sources})\n\n'%(project_name))
		f.write('#add_library(%s_static STATIC ${sources})\n\n'%(project_name))
		f.write('set(CMAKE_INSTALL_PREFIX "%s")\n\n'%(os.path.join(XCMAKE_ARGS.build_dir, XCMAKE_INSTALL_DIR).replace('\\', '/')))
		f.write('install(TARGETS %s DESTINATION bin)\n\n'%(project_name))
		f.write('install(DIRECTORY include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n\n')
		f.write('#install(TARGETS %s_shared DESTINATION lib)\n\n'%(project_name))
		f.write('#install(TARGETS %s_static DESTINATION lib)\n\n'%(project_name))

def do_cmake(args=None, with_argv=True, ddash_args=None):
	cmake_argv = ['cmake']
	if args:
		cmake_argv += args
	if with_argv and XCMAKE_ARGS.cmake_argv:
		cmake_argv += XCMAKE_ARGS.cmake_argv
	if ddash_args:
		if '--' not in XCMAKE_ARGS.cmake_argv:
			cmake_argv.append('--')
		cmake_argv += ddash_args
	subp_check_call(cmake_argv)

def find_cache_entry(name=None):
	try:
		entries = find_cache_entry.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		return entry[0] if entry else ''
	except:
		find_cache_entry.entries = {}
	cmakecache = os.path.join(XCMAKE_ARGS.build_dir, CMAKECACHE)
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(XCMAKE_ARGS.build_dir, CMAKECACHE))
	entries = find_cache_entry.entries
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			entry, value = line.split('=')
			ename, vtype = entry.split(':')
			entries[ename] = (value, vtype)
	return find_cache_entry(name)

def command_version():
	sys.stdout.write('%s version %s\n\n'%(XCMAKE_PROG, XCMAKE_VERSION))
	subp_check_call(['cmake', '--version'], show=False)

def command_scratch():
        cmakelists = os.path.abspath(CMAKELISTS)
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		do_scratch(cmakelists)
	except:
		os.remove(cmakelists)
		raise

def command_cmake():
	do_cmake(['-E', 'chdir', XCMAKE_ARGS.build_dir, 'cmake'])

def command_update(args = None, with_argv=True):
	argv = ['-H' + XCMAKE_ARGS.directory, '-B' + XCMAKE_ARGS.build_dir]
	if args:
		argv += args
	do_cmake(argv, with_argv=with_argv)

def do_build_target(target=None, ddash_args=None):
	argv = ['--build', XCMAKE_ARGS.build_dir]
	if target:
		argv += ['--target', target]
	do_cmake(argv, ddash_args=ddash_args)

def generator_jobs_arg():
	gen = find_cache_entry('CMAKE_GENERATOR')
	if gen:
		if gen.find('Visual Studio') >= 0:
			return ('/m', '/m:%d')
	return ('-j', '-j%d')

def build_native_args():
	args = None
	if XCMAKE_ARGS.jobs == None: 
		args = [generator_jobs_arg()[0]]
	elif XCMAKE_ARGS.jobs >= 0:
		args = [generator_jobs_arg()[1]%(XCMAKE_ARGS.jobs)]
	return args

def command_build(update=True):
	if update and (not os.path.exists(XCMAKE_ARGS.build_dir) or not os.listdir(XCMAKE_ARGS.build_dir)):
		command_update(with_argv=False)
	ddash_args = build_native_args()
	if not XCMAKE_ARGS.target:
		return do_build_target(None, ddash_args)
	targets = set()
	for target in XCMAKE_ARGS.target:
		if target in targets:
			continue
		targets.add(target)
		do_build_target(target, ddash_args)

def command_make_with_update():
	command_update(with_argv=False)
	command_build(update=False)

def command_clean():
	if os.path.exists(XCMAKE_ARGS.build_dir):
		if XCMAKE_ARGS.directory == XCMAKE_ARGS.build_dir:
			raise XCMakeError('The build directory "%s" is source directory.'%(XCMAKE_ARGS.build_dir))
	subp_check_call(['cmake', '-E', 'remove_directory', XCMAKE_ARGS.build_dir])

def command_show(status=False):
	internal_entries = []
	cmake_entries = []
	entries = []
	for name, (value, vtype) in find_cache_entry().iteritems():
		if not value:
			continue
		if vtype == 'INTERNAL':
			if not status or (name.startswith('CMAKE_GENERATOR') or name.endswith('_COMMAND') or name.endswith('_DIR') or name.endswith('_DIRECTORY')):
				internal_entries.append((name, value))
			continue
		if status:
			continue
		if vtype == 'PATH' or vtype == 'FILEPATH':
			if value.endswith('-NOTFOUND'):
				continue
		if name.startswith('CMAKE_'):
			cmake_entries.append((name, vtype, value))
		else:
			entries.append((name, vtype, value))
	echo_color('INTERNAL:', color='cyan')
	for name, value in sorted(internal_entries):
		sys.stdout.write('%s=%s\n'%(name, value))
	if cmake_entries:
		echo_color('EXTERNAL-CMAKE:', color='cyan')
		for name, vtype, value in sorted(cmake_entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))
	if entries:
		echo_color('EXTERNAL:', color='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

def command_status():
	command_show(status=True)

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\n\n'%(self.prog, message))
		self.print_help(sys.stderr)
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(values))

def parse_arguments(args):
	parser = ArgumentParser(prog=XCMAKE_PROG, description=XCMAKE_DESCRIPTION)
	# make
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-v', '--version', action='store_true', help='Display version and exit')
	# xcmake
	parser.add_argument('-B', '--build-dir', action=PathAction, help='Default "%s"(base on -C)'%(XCMAKE_BUILD_DIR))
	parser.add_argument('--scratch', action='store_true', help='Create a %s template'%(CMAKELISTS))
	parser.add_argument('--update', action='store_true', help='Update or create cmake cache')
	parser.add_argument('--build', action='store_true', help='Make targets without update')
	parser.add_argument('--clean', action='store_true', help='Remove BUILD_DIR')
	parser.add_argument('--status', action='store_true', help='Show cache status')
	parser.add_argument('--show', action='store_true', help='Show cache entries')
	parser.add_argument('--cmake', action='store_true', help='Run cmake in BUILD_DIR')
	# only for help
	parser.add_argument('--', dest='cmake_argv', metavar='', help='Pass remaining options to cmake')

	global XCMAKE_ARGS
	XCMAKE_ARGS = parser.parse_args(args)

	if XCMAKE_ARGS.directory:
		os.chdir(XCMAKE_ARGS.directory)
	else:
		XCMAKE_ARGS.directory = os.getcwd()
	if not XCMAKE_ARGS.build_dir:
		XCMAKE_ARGS.build_dir = os.path.abspath(XCMAKE_BUILD_DIR)

def main():
	argv = sys.argv[1:]
	cmake_argv_idx = len(argv)
	try:
		cmake_argv_idx = argv.index('--')
	except:
		pass
	parse_arguments(argv[:cmake_argv_idx])
	setattr(XCMAKE_ARGS, 'cmake_argv', argv[cmake_argv_idx + 1:])

	#print(XCMAKE_ARGS)
	if XCMAKE_ARGS.version:
		return command_version()
	if XCMAKE_ARGS.cmake:
		return command_cmake()
	if XCMAKE_ARGS.status:
		return command_status()
	if XCMAKE_ARGS.show:
		return command_show()
	if XCMAKE_ARGS.scratch:
		return command_scratch()
	if XCMAKE_ARGS.clean:
		return command_clean()
	if XCMAKE_ARGS.update:
		return command_update()
	if XCMAKE_ARGS.build:
		return command_build()
	return command_make_with_update()

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError, e:
		sys.exit(e.returncode)
	except Exception, e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

