#!/usr/bin/env python

import sys
import os
import subprocess
import argparse
import shutil

CMAKE_COMMAND = os.environ.get('CMAKE') or 'cmake'
CMAKELISTS = 'CMakeLists.txt'
CMAKECACHE = 'CMakeCache.txt'

class XCMAKE:
	NAME = 'XCMake'
	VERSION='1.0.0'
	DESCRIPTION = 'XCMake - Make frontend for cmake'
	PROG = os.path.basename(sys.argv[0])
	COMMAND = os.path.abspath(sys.argv[0])
	BUILD_DIR = os.environ.get('XCMAKE_BUILD_DIR') or 'build_xcmake'
	SEARCH_CMAKELISTS = True
	CMAKE_MIN_VERSION = '3.3'
	ARGS = None

class XCMakeError(Exception):
	pass

def print_color(text, end='\n', file=sys.stdout, flush=False, attrs=None):
	if attrs:
		argv = ['cmake', '-E', 'cmake_echo_color', '--no-newline']
		argv += ('--%s'%(attr.strip()) for attr in attrs.split(','))
		argv.append(text)
		file.flush()
		subprocess.check_call(argv, stdout=file)
	else:
		file.write(text)
	if end:
		file.write(end)
	if flush:
		file.flush()

def subp_escape(arg):
	if not arg or ' ' in arg:
		return '"%s"'%(arg)
	return arg

def subp_check_call(args, output=False, echo=True):
	if echo:
		print_color(' '.join((subp_escape(arg) for arg in args)), attrs='green,bold')
	sys.stdout.flush()
	sys.stderr.flush()
	if output:
		return subprocess.check_output(args)
	else:
		subprocess.check_call(args)

def search_cmakelists(cdir):
	while not os.path.exists(os.path.join(cdir, CMAKELISTS)):
		cdir, f = os.path.split(cdir)
		if not f:
			return None
	return os.path.normpath(cdir)

def xcmake_directory():
	if not XCMAKE.ARGS.directory:
		cwd = os.getcwd()
		if XCMAKE.SEARCH_CMAKELISTS:
			cdir = search_cmakelists(cwd)
			if cdir:
				if cdir != cwd:
					os.chdir(cdir)
					cwd = cdir
			else:
				raise XCMakeError('Not a cmake project (or any of the parent directories): %s'%(CMAKELISTS))
		XCMAKE.ARGS.directory = cwd
	return XCMAKE.ARGS.directory

def xcmake_build_directory():
	if not XCMAKE.ARGS.build_dir:
		XCMAKE.ARGS.build_dir = os.path.normpath(os.path.join(xcmake_directory(), XCMAKE.BUILD_DIR))
	return XCMAKE.ARGS.build_dir

def xcmake_cmakelists():
	return os.path.join(xcmake_directory(), CMAKELISTS)

def xcmake_cmakecache():
	return os.path.join(xcmake_build_directory(), CMAKECACHE)

def split_cmake_cache_entry(entry):
	nametype, value = entry.split('=')
	name_type = nametype.split(':')
	vtype = name_type[1].strip() if len(name_type) > 1 else None
	return (name_type[0].strip(), vtype, value.strip())

def find_cmake_cache_entries(name=None):
	if hasattr(find_cmake_cache_entries, 'entries'):
		entries = find_cmake_cache_entries.entries
		if name == None:
			return entries 
		entry = entries.get(name)
		return entry[0] if entry else ''
	cmakecache = xcmake_cmakecache()
	if not os.path.exists(cmakecache):
		raise XCMakeError('The build directory "%s" does not appear to contain %s.'%(xcmake_build_directory(), CMAKECACHE))
	entries = {}
	with open(cmakecache) as f:
		for line in f:
			line = line.strip()
			if not line or line.startswith('#') or line.startswith('//'):
				continue
			ename, vtype, value = split_cmake_cache_entry(line)
			entries[ename] = (value, vtype)
	find_cmake_cache_entries.entries = entries
	return find_cmake_cache_entries(name)

def do_scratch(cmakelists):
	project_name = os.path.basename(xcmake_directory())
	with open(cmakelists, 'w') as f:
		f.write(
'''# Generated by %(xcmake_name)s.
cmake_minimum_required(VERSION %(min_ver)s)\n
project(%(proj)s CXX)\n
file(GLOB sources LIST_DIRECTORIES false "*.cpp")
file(GLOB_RECURSE src_sources LIST_DIRECTORIES false "src/*.cpp")
list(APPEND sources ${src_sources})\n
add_executable(%(proj)s ${sources})\n
#add_library(%(proj)s STATIC ${sources})
#add_library(%(proj)s SHARED ${sources})\n
target_include_directories(%(proj)s PUBLIC include ${include_dirs})
target_link_libraries(%(proj)s ${libs})\n
install(TARGETS %(proj)s DESTINATION bin)\n
#install(TARGETS %(proj)s DESTINATION lib)
#install(DIRECTORY src/ include/ DESTINATION include FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h")\n
'''		%{
			'xcmake_name': XCMAKE.NAME,
			'min_ver': XCMAKE.CMAKE_MIN_VERSION,
			'proj': project_name,
		})

def do_cmake(args=None, output=False, echo=True, native_args=None, with_hyphen_argv=True):
	cmake_argv = [XCMAKE.ARGS.cmake_command]
	if args:
		cmake_argv += args
	if with_hyphen_argv and XCMAKE.ARGS.hyphen_argv:
		cmake_argv += XCMAKE.ARGS.hyphen_argv
	if native_args:
		if '--' not in cmake_argv:
			cmake_argv.append('--')
		cmake_argv += native_args
	return subp_check_call(cmake_argv, output, echo)

def cmake_generators():
	generators = []
	try:
		cmake_help_text = do_cmake(('-h',), with_hyphen_argv=False, output=True, echo=False).decode('utf8')
		g = False 
		for line in cmake_help_text.splitlines():
			if g:
				generators.append(line)
			elif line.lstrip().startswith('Generators'):
				g = True
	except Exception as e:
		pass
	return generators

def command_version():
	XCMAKE.SEARCH_CMAKELISTS = False
	sys.stdout.write('%s version %s\n\n%s maintained and supported by vby (github.com/vby).\n'
			%(XCMAKE.PROG, XCMAKE.VERSION, XCMAKE.NAME)
		)

def command_scratch():
	XCMAKE.SEARCH_CMAKELISTS = False
	cmakelists = xcmake_cmakelists()
	if os.path.exists(cmakelists):
		raise XCMakeError('"%s" exists.'%(cmakelists))
	try:
		do_scratch(cmakelists)
	except:
		os.remove(cmakelists)
		raise

def command_cmake():
	do_cmake(['-E', 'chdir', xcmake_build_directory(), XCMAKE.ARGS.cmake_command])

def do_update(with_hyphen_argv=True):
	argv = ['-H' + xcmake_directory(), '-B' + xcmake_build_directory()]
	if XCMAKE.ARGS.U:
		for u in XCMAKE.ARGS.U:
			argv.append('-D' + u)
	#argv.append('-DXCMAKE_COMMAND:INTERNAL=' + XCMAKE.COMMAND)
	cmake_module_path = ([], None)
	if XCMAKE.ARGS.D:
		for d in XCMAKE.ARGS.D:
			name, vtype, value = split_cmake_cache_entry(d)
			if name == 'CMAKE_MODULE_PATH':
				cmake_module_path = (value, vtype)
				continue
			argv.append('-D' + d)
	cmake_module_path[0].append(os.path.dirname(XCMAKE.COMMAND))
	argv.append('-DCMAKE_MODULE_PATH%s=%s'%(':' + cmake_module_path[1] if cmake_module_path[1] else '', ';'.join(cmake_module_path[0])))
	if XCMAKE.ARGS.generator != None:
		argv += ['-G', XCMAKE.ARGS.generator]
	if XCMAKE.ARGS.toolset != None:
		argv += ['-T', XCMAKE.ARGS.toolset]
	if XCMAKE.ARGS.platform != None:
		argv += ['-A', XCMAKE.ARGS.platform]
	if XCMAKE.ARGS.trace_expand:
		argv.append('--trace-expand')
	elif XCMAKE.ARGS.trace:
		argv.append('--trace')
	if XCMAKE.ARGS.debug != False:
		argv.append('--debug-output')
	do_cmake(argv, with_hyphen_argv=with_hyphen_argv)

def command_update():
	do_update(with_hyphen_argv=True)

def do_build_target(target=None, args=None, native_args=None):
	argv = ['--build', xcmake_build_directory()]
	if args:
		argv += args
	if target:
		argv += ['--target', target]
	do_cmake(argv, native_args=native_args)

def build_native_arg(arg):
	if hasattr(build_native_arg, 'args'):
		return build_native_arg.args.get(arg)
	args = {}
	gen = find_cmake_cache_entries('CMAKE_GENERATOR')
	if gen and gen.find('Visual Studio') >= 0:
		args['property'] = '/p:%s'
		args['jobs'] = ('/m', '/m:%d')
		args['trace'] = '/v:d' 
		args['debug'] = ('/v:diag', lambda x: '/v:diag' if x == 'a' else '/v:d')
		args['silent'] = ('/nologo', '/v:q')
	else:
		args['property'] = '%s'
		args['jobs'] = ('-j', '-j%d')
		args['trace'] = '--trace' 
		args['debug'] = ('-d', lambda x: '--debug=%s'%(x))
		args['silent'] = ('-s',)
	build_native_arg.args = args
	return build_native_arg(arg)

def build_native_args():
	args = []
	# properties in targets
	if XCMAKE.ARGS.target:
		targets = []
		for target in XCMAKE.ARGS.target:
			if '=' in target:
				args.append(build_native_arg('property')%(target))
			else:
				targets.append(target)
		XCMAKE.ARGS.target = targets
	# -j --jobs
	if XCMAKE.ARGS.jobs == None: 
		args.append(build_native_arg('jobs')[0])
	elif XCMAKE.ARGS.jobs >= 0:
		args.append(build_native_arg('jobs')[1]%(XCMAKE.ARGS.jobs))
	# --trace
	if XCMAKE.ARGS.trace:
		args.append(build_native_arg('trace'))
	# -d --deubg
	if XCMAKE.ARGS.debug != False:
		if XCMAKE.ARGS.debug == '':
			args.append(build_native_arg('debug')[0])
		else:
			args.append(build_native_arg('debug')[1](XCMAKE.ARGS.debug))
	# -s --silent
	if XCMAKE.ARGS.silent:
		args.extend(build_native_arg('silent'))
	return args

def command_build(update=True):
	if update and not os.path.exists(xcmake_cmakecache()):
		do_update(with_hyphen_argv=False)
	args = None
	if XCMAKE.ARGS.config:
		args = ['--config', XCMAKE.ARGS.config] 
	else:
		build_type = find_cmake_cache_entries('CMAKE_BUILD_TYPE')
		if build_type:
			args = ['--config', build_type] 
	native_args = build_native_args()
	if not XCMAKE.ARGS.target:
		return do_build_target(None, args, native_args)
	targets = set()
	for target in XCMAKE.ARGS.target:
		if target in targets:
			continue
		targets.add(target)
		do_build_target(target, args, native_args)

def command_update_build():
	do_update(with_hyphen_argv=False)
	command_build(update=False)

def command_clean():
	build_dir = xcmake_build_directory()
	if os.path.exists(build_dir):
		if xcmake_directory() == build_dir:
			raise XCMakeError('The build directory "%s" is source directory.'%(build_dir))
	do_cmake(('-E', 'remove_directory', build_dir))

def command_show(status=False):
	internal_entries = []
	cmake_entries = []
	entries = []
	for name, (value, vtype) in find_cmake_cache_entries().items():
		if not value:
			continue
		if vtype == 'INTERNAL':
			if not status or (name.startswith('CMAKE_GENERATOR') or name.endswith('_COMMAND') or name.endswith('_DIR') or name.endswith('_DIRECTORY')):
				internal_entries.append((name, value))
			continue
		if vtype == 'PATH' or vtype == 'FILEPATH':
			if value.endswith('-NOTFOUND'):
				continue
		if name.startswith('CMAKE_'):
			if status:
				if name.endswith('_PREFIX'):
					cmake_entries.append((name, vtype, value))
			else:
				cmake_entries.append((name, vtype, value))
		else:
			if not status:
				entries.append((name, vtype, value))
	print_color('INTERNAL:', attrs='cyan')
	for name, value in sorted(internal_entries):
		sys.stdout.write('%s=%s\n'%(name, value))
	if cmake_entries:
		print_color('EXTERNAL-CMAKE:', attrs='cyan')
		for name, vtype, value in sorted(cmake_entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))
	if entries:
		print_color('EXTERNAL:', attrs='cyan')
		for name, vtype, value in sorted(entries):
			sys.stdout.write('%s:%s=%s\n'%(name, vtype, value))

def command_status():
	command_show(status=True)

def print_help(parser, fd=sys.stdout):
	parser.print_help()
	fd.write('\nGenerators\n%s\n'%('\n'.join(cmake_generators())))

def command_help(parser):
	print_help(parser)
	sys.exit(0)

class ArgumentParser(argparse.ArgumentParser):
	def error(self, message):
		sys.stderr.write('%s: %s\nSpecify --help or -h or /? for usage\n'%(self.prog, message))
		self.exit(1)

class PathAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		setattr(namespace, self.dest, os.path.abspath(values))

class PathOrNameAction(argparse.Action):
	def __call__(self, parser, namespace, values, option_string=None):
		if not os.path.dirname(values):
			setattr(namespace, self.dest, values)
		else:
			setattr(namespace, self.dest, os.path.abspath(values))

def adjust_arguments(parser, hyphen_argv):
	# show help
	if XCMAKE.ARGS.help:
		command_help(parser)
	# --debug
	if XCMAKE.ARGS.debug:
		if 'n' in XCMAKE.ARGS.debug:
			XCMAKE.ARGS.debug = False
			XCMAKE.ARGS.d = False
	if XCMAKE.ARGS.debug == None or (XCMAKE.ARGS.d and not XCMAKE.ARGS.debug):
		XCMAKE.ARGS.debug = 'a'
	# set --trace for --trace-expand
	if XCMAKE.ARGS.trace_expand:
		XCMAKE.ARGS.trace = True
	# --silent
	if XCMAKE.ARGS.silent:
		XCMAKE.ARGS.debug = False
		XCMAKE.ARGS.trace = False
		XCMAKE.ARGS.trace_expand = False
	# set --update for -G -T -A -D -U
	if not XCMAKE.ARGS.update:
		if XCMAKE.ARGS.generator != None or XCMAKE.ARGS.toolset != None or XCMAKE.ARGS.platform != None or XCMAKE.ARGS.D or XCMAKE.ARGS.U:
			XCMAKE.ARGS.update = True
	# set -- //
	setattr(XCMAKE.ARGS, 'hyphen_argv', hyphen_argv)

def split_arguments(argv):
	args = [arg if arg != '//' else '--' for arg in argv]
	hyphen_arg_idx = 0
	for arg in args:
		hyphen_arg_idx += 1
		if arg == '--cmake' or arg == '--':
			break
	return (args[:hyphen_arg_idx], args[hyphen_arg_idx:]) 

def parse_arguments(argv):
	parser = ArgumentParser(prog=XCMAKE.PROG, 
		prefix_chars='-/',
		formatter_class=argparse.RawDescriptionHelpFormatter,
		description=XCMAKE.DESCRIPTION, 
		add_help=False)
	# make
	parser.add_argument('target', nargs='*', help='Targets to make')
	parser.add_argument('-C', '--directory', action=PathAction, help='Change to DIRECTORY before doing anything')
	parser.add_argument('-j', '--jobs', metavar='N', type=int, nargs='?', default=-1, help='Allow N jobs at once; infinite jobs with no arg')
	parser.add_argument('-h', '--help', '/?', action='store_true', help='Print this message and exit')
	parser.add_argument('-d', action='store_true', help='Print lots of debugging information')
	parser.add_argument('--debug', metavar='FLAGS', nargs='?', default=False, help='Print various types of debugging information')
	parser.add_argument('--trace', action='store_true', help='Print tracing information')
	parser.add_argument('-s', '--silent', '--quiet', action='store_true', help='Don\'t echo recipes')
	parser.add_argument('-v', '--version', '/V', action='store_true', help='Print the version number of xcmake and exit')
	# cmake extend
	parser.add_argument('--trace-expand', action='store_true', help='Trace with variable expansion')
	# common
	parser.add_argument('-c', '--cmake-command', action=PathOrNameAction, default=CMAKE_COMMAND, help='Default "%s"'%(CMAKE_COMMAND))
	parser.add_argument('-b', '--build-dir', action=PathAction, help='Default DIRECTORY/"%s"'%(XCMAKE.BUILD_DIR))
	# command scratch
	parser.add_argument('--scratch', action='store_true', help='Create a %s template'%(CMAKELISTS))
	# command update
	parser.add_argument('--update', action='store_true', help='Create or update CMake cache')
	parser.add_argument('-G', '--generator', help='Specify a build system generator')
	parser.add_argument('-T', '--toolset', help='Specify toolset name if supported by GENERATOR')
	parser.add_argument('-A', '--platform', help='Specify platform name if supported by GENERATOR')
	# BUG of parser: '[' in metavar
	parser.add_argument('-D', metavar='<var>{:<type>}=<value>', action='append', help='Create a cmake cache entry')
	parser.add_argument('-U', metavar='<globbing_expr>', action='append', help='Remove matching entries from CMake cache')
	# command build
	parser.add_argument('--build', action='store_true', help='Make targets')
	parser.add_argument('--config', help='For multi-configuration tools, choose CONFIG')
	# command clean
	parser.add_argument('--clean', action='store_true', help='Remove BUILD_DIR')
	# command status
	parser.add_argument('--status', action='store_true', help='Show cache status')
	# command show
	parser.add_argument('--show', action='store_true', help='Show cache entries')
	# command cmake
	parser.add_argument('--cmake', action='store_true', help='Run cmake in BUILD_DIR')
	# only for help
	parser.add_argument('--', dest='hyphen_argv', metavar='or //', help='Pass remaining options to cmake')

	args, hyphen_argv = split_arguments(argv)
	XCMAKE.ARGS = parser.parse_args(args)
	adjust_arguments(parser, hyphen_argv)

def main():
	parse_arguments(sys.argv[1:])
	
	#print(XCMAKE.ARGS)
	if XCMAKE.ARGS.version:
		return command_version()
	if XCMAKE.ARGS.cmake:
		return command_cmake()
	if XCMAKE.ARGS.status:
		return command_status()
	if XCMAKE.ARGS.show:
		return command_show()
	if XCMAKE.ARGS.scratch:
		return command_scratch()
	if XCMAKE.ARGS.clean:
		return command_clean()
	if XCMAKE.ARGS.update:
		if XCMAKE.ARGS.build:
			return command_update_build()
		return command_update()
	return command_build()

if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		sys.exit(255)
	except subprocess.CalledProcessError as e:
		sys.exit(e.returncode)
	except Exception as e:
		sys.stderr.write('%s: %s\n'%(type(e).__name__, str(e)))
		sys.exit(254)

